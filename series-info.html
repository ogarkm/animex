<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Series Info - Media App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="Resources/styles.css">
    <link rel="stylesheet" href="Resources/series.css">
    <style>
        .episode-item.watched {
            background: rgba(255, 149, 0, 0.1);
            border-bottom: 3px solid #FF9500;
        }

        .episode-item.watched:hover {
            background: rgba(255, 149, 0, 0.15);
        }

        /* Watched indicator icon */
        .watched-indicator {
            color: #FF9500;
            font-size: 0.9em;
        }

        /* Enhanced episode number styling for watched episodes */
        .episode-number.watched {
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- ****** START: ADD BACK BUTTON ****** -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const showBackBtn = urlParams.get('anime') === 'true';
            const backBtn = document.getElementById('back-button');
            if (backBtn) {
                backBtn.style.display = showBackBtn ? '' : 'none';
            }
        });
    </script>
        <!-- ****** END: ADD BACK BUTTON ****** -->

        <header class="series-hero-section">
            <button id="back-button" class="back-btn">
                <i class="fas fa-arrow-left"></i>
            </button>
            <div class="series-hero-content">
                <h1 class="series-title-text"></h1>
            </div>
            <div class="hero-overlay"></div>
            
        </header>

        <main class="main-content series-main-content">
            <section class="series-details-section">
                <h2 id="series-main-title-backup" style="display:none; font-size: 1.8em; margin-bottom: 15px;"></h2>
                <div class="series-meta-info">
                    <span id="series-score"></span>
                    <span id="series-year"></span>
                    <span id="series-type"></span>
                    <span id="series-episodes-count"></span>
                    <span id="series-status"></span>
                    <span id="series-rating"></span>
                </div>
                <p id="series-synopsis"></p>
                <div id="series-info-additional">
                    <p><strong>English Title:</strong> <span id="series-title-english"></span></p>
                    <p><strong>Japanese Title:</strong> <span id="series-title-japanese"></span></p>
                    <p><strong>Source:</strong> <span id="series-source"></span></p>
                    <p><strong>Duration:</strong> <span id="series-duration"></span></p>
                </div>
                <div class="series-genres"></div>
                <div class="series-studios"></div>
                <div class="series-producers"></div>
            </section>

            <section class="episode-list-section" id="episode-list-section">
                <h2 class="section-title">Episodes</h2>
                <div class="episode-list" id="episode-list-container"></div>
                <div id="episodes-pagination" class="episodes-pagination">
                    <button id="prev-episodes-btn" style="display:none;">Previous</button>
                    <span id="episodes-page-info"></span>
                    <button id="next-episodes-btn" style="display:none;">Next</button>
                </div>
            </section>
        </main>
    </div>

    <!-- Episode Pop-up Overlay -->
    <!-- Replace the existing close button in the popup -->
    <div id="episode-popup-overlay" class="episode-popup-overlay" style="display:none;">
        <div class="episode-popup-content">
            <button class="episode-popup-back" title="Back">
                <i class="fas fa-arrow-left"></i>
            </button>
            <iframe id="episode-popup-iframe" src="" frameborder="0" allowfullscreen></iframe>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ****** START: BACK BUTTON LOGIC ******
            const urlParams = new URLSearchParams(window.location.search);
            const isAnime = urlParams.get('anime') === 'true';
            const isManga = urlParams.get('manga') === 'true';
            const isLibrary = urlParams.get('library') === 'true';
            const type = isManga ? 'manga' : 'anime';
            const API_BASE_URL = 'https://arkm20-authapi.hf.space';
            let userWatchHistory = null;
            const backButton = document.getElementById('back-button');
            if (backButton) {
                backButton.style.display = (isAnime || isManga || isLibrary) ? '' : 'none';
                backButton.addEventListener('click', () => {
                    if (isLibrary === true) {
                        window.location.href = 'library.html';
                    } else {
                        window.location.href = isManga ? 'manga.html' : 'anime.html';
                    }
                });
            }
            // ****** END: BACK BUTTON LOGIC ******

            const heroSection = document.querySelector('.series-hero-section');
            const seriesTitleTextElement = document.querySelector('.series-title-text');
            const seriesMainTitleBackup = document.getElementById('series-main-title-backup');

            const seriesScoreElement = document.getElementById('series-score');
            const seriesYearElement = document.getElementById('series-year');
            const seriesTypeElement = document.getElementById('series-type');
            const seriesEpisodesCountElement = document.getElementById('series-episodes-count');
            const seriesStatusElement = document.getElementById('series-status');
            const seriesRatingElement = document.getElementById('series-rating');
            const seriesSynopsisElement = document.getElementById('series-synopsis');
            const seriesGenresContainer = document.querySelector('.series-genres');
            const seriesStudiosContainer = document.querySelector('.series-studios');
            const seriesProducersContainer = document.querySelector('.series-producers');

            const seriesTitleEnglishElement = document.getElementById('series-title-english');
            const seriesTitleJapaneseElement = document.getElementById('series-title-japanese');
            const seriesSourceElement = document.getElementById('series-source');
            const seriesDurationElement = document.getElementById('series-duration');

            const episodeListContainer = document.getElementById('episode-list-container');
            const episodesPaginationContainer = document.getElementById('episodes-pagination');

            let currentSeriesId = null;
            let episodesData = [];
            let currentPage = 1;
            const episodesPerPage = 25;

            if( type !== 'anime') {
                const episodeListSection = document.getElementById('episode-list-section');
                if (episodeListSection) {
                    episodeListSection.style.display = 'none'; // Hide episode list section for manga
                }
            }
            function getSeriesIdFromUrl() {
                const params = new URLSearchParams(window.location.search);
                return params.get('id');
            }

            async function fetchSeriesDetails(seriesId) {
                try {
                    const response = await fetch(`https://api.jikan.moe/v4/${type}/${seriesId}/full`);
                    if (!response.ok) throw new Error(`Jikan API error (details): ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    console.log(`Fetched ${type} details:`, data.data);
                    return data.data;
                } catch (error) {
                    console.error(`Failed to fetch ${type} details:`, error);
                    displayError('Could not load series details. Please try again later.');
                }
            }

            async function fetchSeriesEpisodes(seriesId) {
                if (type !== 'anime') return [];
                let allEpisodes = [];
                let page = 1;
                let hasMorePages = true;

                try {
                    while (hasMorePages) {
                        const response = await fetch(`https://api.jikan.moe/v4/anime/${seriesId}/episodes?page=${page}`);
                        if (!response.ok) {
                            if (page === 1) throw new Error(`Jikan API error (episodes): ${response.status} ${response.statusText}`);
                            else {
                                console.warn(`Failed to fetch episode page ${page}: ${response.status}`);
                                hasMorePages = false;
                                break;
                            }
                        }
                        const data = await response.json();
                        if (data.data && data.data.length > 0) {
                            allEpisodes = allEpisodes.concat(data.data);
                        } else {
                            hasMorePages = false;
                        }
                        
                        if (data.pagination && data.pagination.has_next_page) {
                            page++;
                            await new Promise(resolve => setTimeout(resolve, 300));
                        } else {
                            hasMorePages = false;
                        }
                    }
                    return allEpisodes;
                } catch (error) {
                    console.error("Failed to fetch anime episodes:", error);
                    episodeListContainer.innerHTML = '<p>Could not load episodes.</p>';
                    return [];
                }
            }
        

            /*async function updateWatchHistory(showId, showTitle, seasonNumber, episodeNumber) {
                // Check for the access token in localStorage
                const token = localStorage.getItem('accessToken');

                // If no token exists, the user is not logged in. Do nothing.
                if (!token) {
                    console.log("User is not logged in. Skipping watch history update.");
                    return;
                }

                console.log(`Updating watch history for: ${showId} | ${showTitle} - S${seasonNumber}E${episodeNumber}`);

                try {
                    // The API endpoint expects a specific JSON structure in the body
                    const body = {
                        show_id: String(showId),
                        show_title: String(showTitle),
                        season_number: Number(seasonNumber),
                        episode_number: Number(episodeNumber)
                    };

                    console.log("Watch history body:", body);

                    const response = await fetch(`${API_BASE_URL}/users/me/watch-history`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}` // Include the user's token
                        },
                        body: JSON.stringify(body)
                    });

                    console.log("Watch history update response status:", response.status);

                    // We don't need to wait for the response, but it's good practice to log the result for debugging.
                    if (response.ok) {
                        console.log("Watch history updated successfully.");
                    } else {
                        const errorData = await response.json();
                        console.error("Failed to update watch history:", errorData.detail || response.statusText);
                    }
                } catch (error) {
                    console.error("Network error while updating watch history:", error);
                }
            }

            // SNIPPET 2: Place this function inside the DOMContentLoaded listener.

            async function updateWatchHistory(showId, showTitle, seasonNumber, episodeNumber) {
                const token = localStorage.getItem('accessToken');
                console.log("Access token:", token);
                if (!token) {
                    console.log("User not logged in. Skipping watch history update.");
                    // You might want to prompt the user to log in here.
                    // For example: alert("Please log in to save your watch history.");
                    return;
                }

                console.log(`Updating watch history for: ${showId} - ${showTitle} - S${seasonNumber}E${episodeNumber}`);

                try {
                    const params = new URLSearchParams({
                        show_id: String(showId),
                        show_title: String(showTitle),
                        season_number: Number(seasonNumber),
                        episode_number: Number(episodeNumber)
                    });

                    const url = `https://arkm20-authapi.hf.space/users/me/watch-history?${params.toString()}`;

                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log("Watch history update successful:", result.message);
                    } else {
                        // Specifically check for the authentication error code
                        if (response.status === 401) {
                            console.error("Authentication failed. The token is likely expired or invalid.");
                            // This is a great place to redirect the user to a login page
                            // or show a "Your session has expired, please log in again" message.
                            // For example:
                            // localStorage.removeItem('accessToken'); // Clear the bad token
                            // window.location.href = '/login/login.html'; // Redirect to login
                        }

                        // Handle other potential errors (like 404 Not Found, 500 Server Error)
                        const errorData = await response.json();
                        console.error(`Failed to update watch history (${response.status}):`, errorData.detail || response.statusText);
                    }
                } catch (error) {
                    console.error("Network error while updating watch history:", error);
                }
            }*/

            // ===== Glassy Download Button Logic =====

            function displayAnimeDetails(anime) {
                if (!anime) return;

                const heroImageUrl = anime.images?.jpg?.large_image_url || anime.images?.jpg?.image_url || 'https://placehold.co/1200x700/1A2B3C/FFF?text=No+Image+Available';
                heroSection.style.backgroundImage = `url('${heroImageUrl}')`;

                const displayTitle = anime.title_english || anime.title;
                currentSeriesTitle = displayTitle;
                seriesTitleTextElement.textContent = displayTitle;
                seriesMainTitleBackup.textContent = displayTitle;
                document.title = `${displayTitle} - Series Info`;

                seriesScoreElement.textContent = anime.score ? `Score: ${anime.score}/10 (${anime.scored_by?.toLocaleString() || 0} users)` : 'N/A';
                seriesYearElement.textContent = `Year: ${anime.year || (anime.aired?.prop?.from?.year || 'N/A')}`;
                seriesTypeElement.textContent = `Type: ${anime.type || 'N/A'}`;
                seriesEpisodesCountElement.textContent = `Episodes: ${anime.episodes || 'N/A'}`;
                seriesStatusElement.textContent = `Status: ${anime.status || 'N/A'}`;
                seriesRatingElement.textContent = `Rating: ${anime.rating || 'N/A'}`;
                
                seriesSynopsisElement.innerHTML = anime.synopsis ? anime.synopsis.replace(/\n/g, '<br>') : 'No synopsis available.';

                seriesTitleEnglishElement.textContent = anime.title_english || 'N/A';
                seriesTitleJapaneseElement.textContent = anime.title_japanese || 'N/A';
                seriesSourceElement.textContent = anime.source || 'N/A';
                seriesDurationElement.textContent = anime.duration || 'N/A';

                seriesGenresContainer.innerHTML = '<strong>Genres:</strong> ';
                [...anime.genres, ...anime.explicit_genres || [], ...anime.themes || [], ...anime.demographics || []].forEach(g => {
                    const genreSpan = document.createElement('span');
                    genreSpan.textContent = g.name;
                    seriesGenresContainer.appendChild(genreSpan);
                });
                
                seriesStudiosContainer.innerHTML = '<strong>Studios:</strong> ';
                anime.studios.forEach(s => {
                    const studioSpan = document.createElement('span');
                    studioSpan.textContent = s.name;
                    seriesStudiosContainer.appendChild(studioSpan);
                });

                seriesProducersContainer.innerHTML = '<strong>Producers:</strong> ';
                anime.producers.forEach(p => {
                    const producerSpan = document.createElement('span');
                    producerSpan.textContent = p.name;
                    seriesProducersContainer.appendChild(producerSpan);
                });
            }

            function displayEpisodes(episodes) {
                episodeListContainer.innerHTML = '';
                if (!episodes || episodes.length === 0) {
                    episodeListContainer.innerHTML = '<p>No episodes found for this series or they are still loading.</p>';
                    episodesPaginationContainer.innerHTML = '';
                    return;
                }
                episodesData = episodes;
                currentPage = 1;
                renderEpisodePage();
                setupPagination(episodesData.length);
            }


            async function fetchUserWatchHistory() {
                const token = localStorage.getItem('accessToken');
                console.log("Access token found:", token ? "Yes" : "No");
                console.log("Token value:", token);
                
                if (!token) {
                    console.log("No user token found, skipping watch history fetch.");
                    return null;
                }

                try {
                    console.log("Making API request to:", `${API_BASE_URL}/users/me`);
                    
                    const response = await fetch(`${API_BASE_URL}/users/me`, { 
                        headers: { 'Authorization': `Bearer ${token}` } 
                    });

                    console.log("API response status:", response.status);
                    console.log("API response ok:", response.ok);

                    if (response.status === 401) {
                        console.log("Token invalid, clearing token.");
                        localStorage.removeItem('accessToken');
                        return null;
                    }
                    
                    if (!response.ok) {
                        console.error(`API error: ${response.status} ${response.statusText}`);
                        throw new Error(`API error: ${response.status}`);
                    }

                    const userData = await response.json();
                    console.log("Full user data received:", userData);
                    console.log("Watch history detailed:", userData.watch_history_detailed);
                    
                    if (!userData.watch_history_detailed) {
                        console.log("No watch_history_detailed field in user data");
                        return null;
                    }
                    
                    if (Object.keys(userData.watch_history_detailed).length === 0) {
                        console.log("Watch history is empty");
                        return null;
                    }
                    
                    console.log("Watch history successfully loaded with", Object.keys(userData.watch_history_detailed).length, "series");
                    return userData.watch_history_detailed;

                } catch (error) {
                    console.error("Failed to fetch user watch history:", error);
                    console.error("Error details:", error.message);
                    return null;
                }
            }

            function isEpisodeWatched(seriesId, seasonNumber, episodeNumber) {
                console.log(`Checking if watched: Series ${seriesId}, Season ${seasonNumber}, Episode ${episodeNumber}`);
                
                if (!userWatchHistory) {
                    console.log("No watch history available");
                    return false;
                }

                console.log("Available series in watch history:", Object.keys(userWatchHistory));
                
                if (!userWatchHistory[seriesId]) {
                    console.log(`Series ${seriesId} not found in watch history`);
                    return false;
                }

                const series = userWatchHistory[seriesId];
                console.log(`Series ${seriesId} data:`, series);
                
                if (!series.seasons || !series.seasons[seasonNumber]) {
                    console.log(`Season ${seasonNumber} not found for series ${seriesId}`);
                    console.log("Available seasons:", series.seasons ? Object.keys(series.seasons) : "No seasons");
                    return false;
                }

                const season = series.seasons[seasonNumber];
                console.log(`Season ${seasonNumber} data:`, season);
                
                const isWatched = season.episodes && season.episodes[episodeNumber];
                console.log(`Episode ${episodeNumber} watched:`, isWatched);
                
                return isWatched;
            }

            function renderEpisodePage() {
                episodeListContainer.innerHTML = '';
                const start = (currentPage - 1) * episodesPerPage;
                const end = start + episodesPerPage;
                const paginatedEpisodes = episodesData.slice(start, end);

                console.log("Current series ID:", currentSeriesId);
                console.log("Rendering episodes:", paginatedEpisodes.length);

                paginatedEpisodes.forEach((episode) => {
                    const episodeItem = document.createElement('div');
                    episodeItem.classList.add('episode-item');
                    episodeItem.style.display = 'flex';
                    episodeItem.style.alignItems = 'center';
                    episodeItem.style.gap = '12px';

                    // Try multiple season numbers since we don't know which one is correct
                    let isWatched = false;
                    for (let season = 1; season <= 3; season++) {
                        if (isEpisodeWatched(currentSeriesId, season, episode.mal_id)) {
                            isWatched = true;
                            console.log(`Found watched episode ${episode.mal_id} in season ${season}`);
                            break;
                        }
                    }

                    // Also try episode.mal_id as string
                    if (!isWatched) {
                        for (let season = 1; season <= 3; season++) {
                            if (isEpisodeWatched(currentSeriesId, season, String(episode.mal_id))) {
                                isWatched = true;
                                console.log(`Found watched episode ${episode.mal_id} (as string) in season ${season}`);
                                break;
                            }
                        }
                    }

                    console.log(`Episode ${episode.mal_id} final watched status:`, isWatched);
        
                    // --- Glassy Download Icon Button per episode ---
                    const downloadBtn = document.createElement('button');
                    downloadBtn.className = 'glassy-download-btn episode-download-icon';
                    downloadBtn.title = 'Download Episode';
                    downloadBtn.style.marginTop = '0';
                    downloadBtn.style.padding = '8px 5px';
                    downloadBtn.style.borderRadius = '50%';
                    downloadBtn.style.display = 'flex';
                    downloadBtn.style.paddingRight = '4px';
                    downloadBtn.style.alignItems = 'center';
                    downloadBtn.style.justifyContent = 'center';
                    downloadBtn.style.minWidth = 'unset';
                    downloadBtn.style.width = '25px';
                    downloadBtn.style.height = '25px';
                    downloadBtn.innerHTML = '<i class="fas fa-cloud-download"></i>';
                    // Get quality from localStorage or default to '720p'
                    let quality = localStorage.getItem('quality');
                    if (!quality || typeof quality !== 'string') quality = '720p';
                    downloadBtn.addEventListener('click', async (event) => {
                        event.stopPropagation(); // Prevent episode item click
                        const animeId = currentSeriesId || '52991';
                        let quality = localStorage.getItem('quality');
                        if (!quality || typeof quality !== 'string') quality = '720p';
                        let episodeNum = episode.mal_id; // Use the correct episode number
                        const isDub = true;
                        // Directly open the download link, no JSON parsing needed
                        window.open(`https://arkm20-animex-player-api.hf.space/download?id=${animeId}&episode=${episodeNum}&dub=${isDub}&quality=${quality}`, '_blank');
                    });
                    episodeItem.appendChild(downloadBtn);
                    // --- End Glassy Download Icon Button ---

                    const episodeNumberSpan = document.createElement('span');
                    episodeNumberSpan.classList.add('episode-number');
                    episodeNumberSpan.textContent = episode.mal_id; // Jikan's episode.mal_id is the episode number

                    const episodeInfoDiv = document.createElement('div');
                    episodeInfoDiv.classList.add('episode-info');
                    // Add this after creating the episodeInfoDiv
                    if (isWatched) {
                        // Add watched indicator
                        const watchedIndicator = document.createElement('span');
                        watchedIndicator.className = 'watched-indicator';
                        watchedIndicator.title = 'Watched';
                        episodeItem.appendChild(watchedIndicator);
                        
                        // Add watched class to the entire episode item
                        episodeItem.classList.add('watched');
                        episodeNumberSpan.classList.add('watched');
                    }


                    const episodeTitle = document.createElement('h4');
                    episodeTitle.classList.add('episode-title');
                    episodeTitle.textContent = episode.title || `Episode ${episode.mal_id}`;

                    const episodeTitleRomanji = document.createElement('p');
                    episodeTitleRomanji.classList.add('episode-title-romanji');
                    episodeTitleRomanji.textContent = episode.title_romanji || '';
                    
                    episodeInfoDiv.appendChild(episodeTitle);
                    if(episode.title_romanji && episode.title_romanji !== episode.title) {
                        episodeInfoDiv.appendChild(episodeTitleRomanji);
                    }
                    
                    episodeItem.appendChild(episodeNumberSpan);
                    episodeItem.appendChild(episodeInfoDiv);

                    // Remove any window.location.href navigation!
                    episodeItem.addEventListener('click', (event) => {
                        // Only open popup if not clicking the download button
                        if (event.target.closest('.episode-download-icon')) return;
                        const url = `view.html?id=${encodeURIComponent(currentSeriesId)}&ep=${encodeURIComponent(episode.mal_id)}`;
                        openEpisodePopup(url);
                    });

                    episodeListContainer.appendChild(episodeItem);
                });
            }

            function setupPagination(totalEpisodes) {
                episodesPaginationContainer.innerHTML = ''; // Clear previous pagination
                const pageCount = Math.ceil(totalEpisodes / episodesPerPage);

                if (pageCount <= 1) return;

                const prevButton = document.createElement('button');
                prevButton.innerHTML = '« Prev';
                prevButton.disabled = currentPage === 1;
                prevButton.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        renderEpisodePage();
                        updatePaginationButtons(pageCount);
                    }
                });
                episodesPaginationContainer.appendChild(prevButton);

                const pageInfo = document.createElement('span');
                pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
                pageInfo.style.margin = "0 10px";
                episodesPaginationContainer.appendChild(pageInfo);

                const nextButton = document.createElement('button');
                nextButton.innerHTML = 'Next »';
                nextButton.disabled = currentPage === pageCount;
                nextButton.addEventListener('click', () => {
                    if (currentPage < pageCount) {
                        currentPage++;
                        renderEpisodePage();
                        updatePaginationButtons(pageCount);
                    }
                });
                episodesPaginationContainer.appendChild(nextButton);
            }

            function updatePaginationButtons(pageCount) {
                const prevButton = episodesPaginationContainer.querySelector('button:first-child');
                const nextButton = episodesPaginationContainer.querySelector('button:last-child');
                const pageInfo = episodesPaginationContainer.querySelector('span');

                if (prevButton) prevButton.disabled = currentPage === 1;
                if (nextButton) nextButton.disabled = currentPage === pageCount;
                if (pageInfo) pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
            }

            function displayError(message) {
                const mainContent = document.querySelector('.series-main-content');
                if (mainContent) {
                    mainContent.innerHTML = `<p class="error-message" style="color: #ff6b6b; text-align: center; padding: 30px; font-size: 1.2em;">${message}</p>`;
                }
                if(heroSection) heroSection.style.display = 'none';
                if (backButton && message.includes("No series ID specified")) {
                    backButton.style.display = 'none';
                }
            }

            async function init() {
                currentSeriesId = getSeriesIdFromUrl();
                console.log("Current series ID from URL:", currentSeriesId);
                
                if (!currentSeriesId) {
                    displayError("No series ID specified in the URL. Example: series-info.html?id=5114");
                    return;
                }

                // Fetch user watch history first with debugging
                console.log("Fetching user watch history...");
                userWatchHistory = await fetchUserWatchHistory();
                console.log("Watch history fetch result:", userWatchHistory);

                const seriesDetails = await fetchSeriesDetails(currentSeriesId);
                if (seriesDetails) {
                    displayAnimeDetails(seriesDetails);
                    if (type === 'anime') {
                        const episodes = await fetchSeriesEpisodes(currentSeriesId);
                        displayEpisodes(episodes);
                    } else {
                        if (document.querySelector('.episode-list-section')) {
                            document.querySelector('.episode-list-section').style.display = 'none';
                        }
                    }
                } else {
                    if(heroSection) heroSection.style.display = 'none';
                }
            }

            // ****** EPISODE PAGINATION LOGIC (secondary, potentially conflicting - review if issues arise) ******
            // Declare at top-level only if not already declared
            if (typeof window.episodesDataGlobal === 'undefined') window.episodesDataGlobal = []; // Renamed to avoid conflict
            if (typeof window.currentEpisodesPageGlobal === 'undefined') window.currentEpisodesPageGlobal = 1; // Renamed
            const EPISODES_PER_PAGE_GLOBAL = 10; // Renamed

            function renderEpisodesPageGlobal(page) { // Renamed
                const episodeListContainerGlobal = document.getElementById('episode-list-container'); // This targets the same container
                const pageInfoGlobal = document.getElementById('episodes-page-info');
                const prevBtnGlobal = document.getElementById('prev-episodes-btn');
                const nextBtnGlobal = document.getElementById('next-episodes-btn');
                
                // This logic might conflict with the primary pagination.
                // For now, it's left as is but commented out the direct manipulation if it's not the primary one.
                // If this section is intended to be the main pagination, it should be integrated properly.
                /*
                if (!window.episodesDataGlobal || window.episodesDataGlobal.length === 0) {
                    episodeListContainerGlobal.innerHTML = '<p>No episodes found.</p>'; // Might overwrite primary render
                    if(pageInfoGlobal) pageInfoGlobal.textContent = '';
                    if(prevBtnGlobal) prevBtnGlobal.style.display = 'none';
                    if(nextBtnGlobal) nextBtnGlobal.style.display = 'none';
                    return;
                }
                const totalPages = Math.ceil(window.episodesDataGlobal.length / EPISODES_PER_PAGE_GLOBAL);
                page = Math.max(1, Math.min(page, totalPages));
                window.currentEpisodesPageGlobal = page;
                const start = (page - 1) * EPISODES_PER_PAGE_GLOBAL;
                const end = start + EPISODES_PER_PAGE_GLOBAL;
                const episodesToShow = window.episodesDataGlobal.slice(start, end);
                episodeListContainerGlobal.innerHTML = ''; // Definitely overwrites primary render
                episodesToShow.forEach(ep => {
                    const epDiv = document.createElement('div');
                    epDiv.className = 'episode-item';
                    epDiv.textContent = ep.title || `Episode ${ep.mal_id || ''}`;
                    // Note: This rendering does not include the amvstrm click listener if it takes over.
                    episodeListContainerGlobal.appendChild(epDiv);
                });
                if(pageInfoGlobal) pageInfoGlobal.textContent = `Page ${page} of ${totalPages}`;
                if(prevBtnGlobal) prevBtnGlobal.style.display = page > 1 ? '' : 'none';
                if(nextBtnGlobal) nextBtnGlobal.style.display = page < totalPages ? '' : 'none';
                */
            }
            
            // These listeners are on buttons by ID. If setupPagination clears and recreates buttons
            // without these IDs, these listeners won't work on the new buttons.
            // The `setupPagination` function creates its own buttons and attaches listeners directly.
            // So, these listeners below might be for the initially hidden buttons if they are not replaced.
            const prevEpisodesBtnById = document.getElementById('prev-episodes-btn');
            if (prevEpisodesBtnById) {
                prevEpisodesBtnById.addEventListener('click', () => {
                    // renderEpisodesPageGlobal(window.currentEpisodesPageGlobal - 1);
                    // This might be redundant if setupPagination handles its own buttons.
                });
            }

            const nextEpisodesBtnById = document.getElementById('next-episodes-btn');
            if (nextEpisodesBtnById) {
                nextEpisodesBtnById.addEventListener('click', () => {
                    // renderEpisodesPageGlobal(window.currentEpisodesPageGlobal + 1);
                });
            }

            function setEpisodesGlobal(episodes) { // Renamed
                window.episodesDataGlobal = episodes || [];
                // renderEpisodesPageGlobal(1); // Initial call for the secondary system
            }

            // --- POPUP OVERLAY LOGIC ---
            const popupOverlay = document.getElementById('episode-popup-overlay');
            const popupContent = popupOverlay.querySelector('.episode-popup-content');
            const popupIframe = document.getElementById('episode-popup-iframe');
            const popupCloseBtn = popupOverlay.querySelector('.episode-popup-close');

            function openEpisodePopup(url) {
                popupIframe.src = url;
                popupOverlay.style.display = 'flex';
                // Trigger animation
                setTimeout(() => {
                    popupOverlay.classList.add('active');
                }, 10);
                document.body.style.overflow = 'hidden'; // Prevent background scroll
            }

            function closeEpisodePopup() {
                popupOverlay.classList.remove('active');
                // Wait for animation to finish before hiding
                setTimeout(() => {
                    popupOverlay.style.display = 'none';
                    popupIframe.src = '';
                    document.body.style.overflow = '';
                }, 300);
            }

            const popupBackBtn = popupOverlay.querySelector('.episode-popup-back');
            popupBackBtn.addEventListener('click', closeEpisodePopup);
            popupOverlay.addEventListener('click', (e) => {
                if (e.target === popupOverlay) closeEpisodePopup();
            });
            // --- END POPUP OVERLAY LOGIC ---

            init();
        });
    </script>
    <style>
    /* Glassy Download Button Styles */
    .glassy-download-btn {
        margin-top: 18px;
        font-size: 1.1em;
        font-weight: 600;
        color: #fff;
        background: rgba(255,255,255,0.12);
        border: 1.5px solid rgba(255,255,255,0.25);
        border-radius: 18px;
        box-shadow: 0 4px 24px 0 rgba(0,0,0,0.10), 0 1.5px 6px 0 rgba(255,255,255,0.10) inset;
        backdrop-filter: blur(8px);
        transition: background 0.2s, box-shadow 0.2s, border 0.2s;
        cursor: pointer;
        outline: none;
    }
    .glassy-download-btn:hover {
        background: rgba(255,255,255,0.22);
        border: 1.5px solid rgba(255,255,255,0.35);
        box-shadow: 0 6px 32px 0 rgba(0,0,0,0.16), 0 2px 8px 0 rgba(255,255,255,0.14) inset;
    }

    /* --- Episode Download Icon Button (UI Fix) --- */
    .episode-download-icon {
        margin-right: 4px; /* Reduced gap */
        font-size: 1.3em;
        background: none !important; /* Remove glassy background */
        border: none !important; /* Remove border */
        box-shadow: none !important; /* Remove shadow */
        padding: 0 !important;
        width: 32px !important;
        height: 32px !important;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
        margin-left: 15px;
        margin-right: -25px;
    }
    .episode-download-icon i {
        color: rgb(143, 143, 143);
        font-size: 0.7em;
        pointer-events: none;
    }
    .episode-download-icon:hover {
        background: rgba(58,122,254,0.08) !important;
    }

    /* --- Episode Item Responsive Layout --- */
    .episode-item {
        display: flex;
        align-items: center;
        gap: 8px; /* Reduced gap for tighter layout */
        padding: 8px 0;
    }
    @media (max-width: 600px) {
        .episode-item {
            gap: 4px;
            padding: 6px 0;
        }
        .episode-download-icon {
            width: 28px !important;
            height: 28px !important;
            font-size: 1.1em;
        }
        .episode-number {
            font-size: 1em;
        }
        .episode-title {
            font-size: 1em;
        }
    }

    /* --- Episode Pop-up Overlay Styles --- */
    .episode-popup-overlay {
        position: fixed;
        z-index: 9999;
        top: 0; left: 0; right: 0; bottom: 0;
        width: 100vw; height: 100vh;
        background: rgba(18, 22, 34, 0.92);
        display: none;
        align-items: center;
        justify-content: center;
        transition: background 0.3s cubic-bezier(.4,0,.2,1);
        animation: none;
    }
    .episode-popup-overlay.active {
        animation: popupFadeIn 0.3s cubic-bezier(.4,0,.2,1) forwards;
        display: flex;
    }
    @keyframes popupFadeIn {
        from { background: rgba(18,22,34,0); }
        to { background: rgba(18,22,34,0.92); }
    }
    .episode-popup-content {
        position: relative;
        width: 92vw;
        max-width: 1100px;
        height: 88vh;
        background: rgba(30,34,44,0.98);
        border-radius: 18px;
        box-shadow: 0 8px 48px 0 rgba(0,0,0,0.25);
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: center;
        opacity: 0;
        transform: scale(0.97) translateY(30px);
        transition: opacity 0.3s cubic-bezier(.4,0,.2,1), transform 0.3s cubic-bezier(.4,0,.2,1);
        overflow: hidden;
        animation: none;
    }
    .episode-popup-overlay.active .episode-popup-content {
        opacity: 1;
        transform: scale(1) translateY(0);
        animation: popupContentIn 0.3s cubic-bezier(.4,0,.2,1) forwards;
    }
    @keyframes popupContentIn {
        from { opacity: 0; transform: scale(0.97) translateY(30px); }
        to { opacity: 1; transform: scale(1) translateY(0); }
    }
    .episode-popup-close {
        position: absolute;
        top: 18px;
        right: 24px;
        z-index: 2;
        font-size: 2.2em;
        color: #fff;
        background: rgba(40,40,50,0.18);
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
    }
    .episode-popup-close:hover {
        background: rgba(58,122,254,0.18);
    }
    .episode-popup-content iframe {
        flex: 1 1 auto;
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 0 0 18px 18px;
        background: #181a22;
        min-height: 400px;
    }
        .episode-popup-back {
        position: absolute;
        top: 18px;
        left: 24px;
        z-index: 2;
        font-size: 1.4em;
        color: #fff;
        background: rgba(40,40,50,0.18);
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
    }
    .episode-popup-back:hover {
        background: rgba(58,122,254,0.18);
    }
    @media (max-width: 900px) {
        .episode-popup-content {
            width: 99vw;
            height: 97vh;
            border-radius: 0;
        }
        .episode-popup-content iframe {
            border-radius: 0;
        }
    }
    @media (max-width: 600px) {
        .episode-popup-content {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
        }
        .episode-popup-close {
            top: 8px;
            right: 10px;
            font-size: 1.7em;
            width: 36px;
            height: 36px;
        }
        .episode-popup-back {
            top: 8px;
            left: 10px;
            font-size: 1.2em;
            width: 36px;
            height: 36px;
        }
    }
    /* Subtle closing animation */
    .episode-popup-overlay:not(.active)[style*="display: flex"] .episode-popup-content {
        opacity: 0;
        transform: scale(0.97) translateY(30px);
        transition: opacity 0.3s cubic-bezier(.4,0,.2,1), transform 0.3s cubic-bezier(.4,0,.2,1);
    }
    </style>
</body>
</html>