<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Series Info - Media App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />
    <!-- Add after the existing font-awesome link -->
    <link
      rel="stylesheet"
      href="https://abtp2.github.io/csPlayer/src/csPlayer.css"
    />
    <script src="https://www.youtube.com/iframe_api"></script>
    <link rel="stylesheet" href="Resources/series.css" />
    <style>
      .fallback-warning {
        background-color: #4a3c00;
        color: #ffecb3;
        padding: 10px 15px;
        border-radius: 6px;
        margin-bottom: 15px;
        text-align: center;
        border: 1px solid #7a6300;
      }
      .section-header {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
      }
      .section-title {
        margin: 0;
        flex-shrink: 0;
      }
      .season-selector-container {
        flex-grow: 1;
        min-width: 180px;
        max-width: 350px;
      }
      .season-selector {
        width: 100%;
        padding: 8px 12px;
        border-radius: 8px;
        background-color: var(--background-secondary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        font-family: "Inter", sans-serif;
        font-size: 0.9rem;
        cursor: pointer;
        transition: border-color 0.2s, box-shadow 0.2s;
      }
      .season-selector:hover {
        border-color: var(--brand-accent-faded);
      }
      .season-selector:focus {
        outline: none;
        border-color: var(--brand-accent);
        box-shadow: 0 0 0 2px var(--brand-accent-faded);
      }
      .thumbnail-toggle-btn {
        margin-left: auto; /* Pushes it to the right */
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <!-- ****** START: ADD BACK BUTTON ****** -->
      <script>
        // This script block remains as is, as it's needed for initial setup.
        document.addEventListener("DOMContentLoaded", () => {
          const urlParams = new URLSearchParams(window.location.search);
          const showBackBtn = urlParams.get("anime") === "true";
          const backBtn = document.getElementById("back-button");
          if (backBtn) {
            backBtn.style.display = showBackBtn ? "" : "none";
          }
        });
      </script>
      <!-- ****** END: ADD BACK BUTTON ****** -->

      <header class="series-hero-section">
        <button id="back-button" class="back-btn">
          <i class="fas fa-arrow-left"></i>
        </button>
        <div class="series-hero-content">
          <h1 class="series-title-text"></h1>
          <!-- NEW: Add to List button in hero -->
          <div class="hero-actions">
            <button
              id="add-series-to-list-btn"
              class="hero-action-btn"
              title="Add Series to List"
            >
              <i class="fas fa-bookmark"></i> ADD TO LIST
            </button>
            <button
              id="export-series-btn"
              class="hero-action-btn"
              title="Export Series Package"
            >
              <i class="fas fa-download"></i> EXPORT
            </button>
          </div>
        </div>
        <div class="hero-overlay"></div>
      </header>

      <main class="main-content series-main-content">
        <!-- ****** START: UPDATED DETAILS SECTION WITH COLLAPSIBLE WRAPPER ****** -->
        <section class="series-details-section">
          <div class="series-meta-info">
            <span id="series-score"></span>
            <span id="series-year"></span>
            <span id="series-type"></span>
            <span id="series-episodes-count"></span>
            <span id="series-status"></span>
            <span id="series-rating"></span>
          </div>

          <div id="details-content-wrapper" class="details-content-wrapper">
            <div class="details-grid">
              <div>
                <!-- Left Column -->
                <p id="series-synopsis"></p>
              </div>
              <div>
                <!-- Right Column -->
                <div id="series-info-additional">
                  <p>
                    <strong>English Title:</strong>
                    <span id="series-title-english"></span>
                  </p>
                  <p>
                    <strong>Japanese Title:</strong>
                    <span id="series-title-japanese"></span>
                  </p>
                  <p>
                    <strong>Source:</strong> <span id="series-source"></span>
                  </p>
                  <p>
                    <strong>Duration:</strong>
                    <span id="series-duration"></span>
                  </p>
                </div>
                <div class="series-genres"></div>
                <div class="series-studios"></div>
                <div class="series-producers"></div>
              </div>
            </div>
            <section
              class="trailer-section"
              id="trailer-section"
              style="display: none"
            >
              <div class="trailer-player-container">
                <h3 class="trailer-title">
                  <i class="fas fa-play-circle"></i>
                  Trailer
                </h3>
                <div id="trailer-player"></div>
              </div>
            </section>
          </div>

          <div
            id="show-more-container"
            class="show-more-container"
            style="display: none"
          >
            <button id="show-more-btn" class="show-more-btn">
              <span>Show More</span> <i class="fas fa-chevron-down"></i>
            </button>
          </div>
        </section>
        <!-- ****** END: UPDATED DETAILS SECTION ****** -->

        <!-- ****** START: TABS SYSTEM HTML ****** -->
        <section class="tabs-section" id="tabs-section" style="display: none">
          <div class="tabs-container" id="tabs-container">
            <button class="tab-btn active" data-tab="episodes">Episodes</button>
            <button class="tab-btn" data-tab="related">Related</button>
            <button class="tab-btn" data-tab="recommendations">
              More Like This
            </button>
          </div>
          <div class="tab-content-container">
            <!-- Episodes Panel -->
            <div id="tab-panel-episodes" class="tab-panel active">
              <section class="episode-list-section">
                <div class="section-header">
                  <h2 class="section-title">Episodes</h2>
                  <div class="season-selector-container" style="display: none;">
                    <select id="season-selector" class="season-selector" title="Select a season"></select>
                  </div>
                  <button
                    id="thumbnail-toggle-btn"
                    class="thumbnail-toggle-btn"
                    title="Toggle Thumbnails"
                  >
                    <i class="fas fa-image"></i>
                  </button>
                </div>
                <div class="episodes-loader" id="episodes-loader"></div>
                <div class="episode-list" id="episode-list-container"></div>
                <div id="episodes-pagination" class="episodes-pagination"></div>
              </section>
              <div
                id="next-season-btn-container"
                style="text-align: center; margin-top: 2rem; display: none"
              >
                <button id="next-season-btn" class="show-more-btn">
                  <i class="fas fa-forward"></i> Next Season
                </button>
              </div>
            </div>
            <!-- Related Panel -->
            <div id="tab-panel-related" class="tab-panel">
              <div
                class="related-content-container"
                id="related-content-container"
              >
                <!-- Related content will be generated by JS -->
              </div>
            </div>
            <!-- Recommendations Panel -->
            <div id="tab-panel-recommendations" class="tab-panel">
              <div class="content-grid" id="recommendations-grid">
                <!-- Recommendation cards will be generated by JS -->
              </div>
            </div>
          </div>
        </section>
        <!-- ****** END: TABS SYSTEM HTML ****** -->
      </main>
    </div>

    <!-- Episode Pop-up Overlay -->
    <div
      id="episode-popup-overlay"
      class="episode-popup-overlay"
      style="display: none"
    >
      <div class="episode-popup-content">
        <button class="episode-popup-back" title="Back">
          <i class="fas fa-arrow-left"></i>
        </button>
        <iframe
          id="episode-popup-iframe"
          src=""
          frameborder="0"
          allowfullscreen
        ></iframe>
      </div>
    </div>

    <!-- Confirmation Pop-up -->
    <div
      id="confirmation-popup-overlay"
      class="episode-popup-overlay"
      style="display: none"
    >
      <div id="confirmation-popup-content" class="confirmation-popup-content">
        <h3 id="confirmation-popup-title">Heads Up!</h3>
        <p id="confirmation-popup-message"></p>
        <div class="confirmation-popup-buttons">
          <button id="confirm-btn" class="popup-btn confirm">
            Watch Again
          </button>
          <button id="cancel-btn" class="popup-btn cancel">Cancel</button>
        </div>
      </div>
    </div>

    <script src="src/csplayer.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // ****** START: BACK BUTTON LOGIC ******
        const urlParams = new URLSearchParams(window.location.search);
        const isAnime = urlParams.get("anime") === "true";
        const isManga = urlParams.get("manga") === "true";
        const isLibrary = urlParams.get("library") === "true";
        const type = urlParams.get("type") || (isManga ? "manga" : "anime");
        const API_BASE_URL = "https://arkm20-authapi.hf.space";
        const serverIp = localStorage.getItem("extension_server_ip");
        // At the top of the script, with the other global variables
        let currentProfile = null;

        const serverUrl = `http://${serverIp}:7275`;
        let userWatchHistory = null;
        let localWatchHistory = {};
        let isSyncing = false; // Flag to prevent multiple syncs
        const backButton = document.getElementById("back-button");
        if (backButton) {
          backButton.style.display =
            isAnime || isManga || isLibrary ? "" : "none";
          backButton.addEventListener("click", () => {
            if (isLibrary === true) {
              window.location.href = "library.html";
            } else {
              window.location.href = isManga ? "manga.html" : "anime.html";
            }
          });
        }
        // ****** END: BACK BUTTON LOGIC ******

        const heroSection = document.querySelector(".series-hero-section");
        const seriesTitleTextElement =
          document.querySelector(".series-title-text");
        // NEW: Selector for the hero add to list button
        const addSeriesToListBtn = document.getElementById(
          "add-series-to-list-btn"
        );

        const seriesScoreElement = document.getElementById("series-score");
        const seriesYearElement = document.getElementById("series-year");
        const seriesTypeElement = document.getElementById("series-type");
        const seriesEpisodesCountElement = document.getElementById(
          "series-episodes-count"
        );
        const seriesStatusElement = document.getElementById("series-status");
        const seriesRatingElement = document.getElementById("series-rating");
        const seriesSynopsisElement =
          document.getElementById("series-synopsis");
        const seriesGenresContainer = document.querySelector(".series-genres");
        const seriesStudiosContainer =
          document.querySelector(".series-studios");
        const seriesProducersContainer =
          document.querySelector(".series-producers");

        const seriesTitleEnglishElement = document.getElementById(
          "series-title-english"
        );
        const seriesTitleJapaneseElement = document.getElementById(
          "series-title-japanese"
        );
        const seriesSourceElement = document.getElementById("series-source");
        const seriesDurationElement =
          document.getElementById("series-duration");

        const episodeListContainer = document.getElementById(
          "episode-list-container"
        );
        const episodesPaginationContainer = document.getElementById(
          "episodes-pagination"
        );
        const thumbnailToggleBtn = document.getElementById(
          "thumbnail-toggle-btn"
        );
        const episodesLoader = document.getElementById("episodes-loader");

        const seasonSelectorContainer = document.querySelector('.season-selector-container');
        const seasonSelector = document.getElementById('season-selector');

        const tabsSection = document.getElementById("tabs-section");
        const tabsContainer = document.getElementById("tabs-container");
        const tabPanels = document.querySelectorAll(".tab-panel");
        const relatedContainer = document.getElementById(
          "related-content-container"
        );
        const recommendationsContainer = document.getElementById(
          "recommendations-grid"
        );

        // ****** START: COLLAPSIBLE DETAILS SELECTORS ******
        const detailsWrapper = document.getElementById(
          "details-content-wrapper"
        );
        const showMoreContainer = document.getElementById(
          "show-more-container"
        );
        const showMoreBtn = document.getElementById("show-more-btn");
        const showMoreBtnText = showMoreBtn.querySelector("span");
        // ****** END: COLLAPSIBLE DETAILS SELECTORS ******

        let currentMalId = null;
        let currentKitsuId = null;
        let currentSeriesTitle = "";
        let episodesData = [];
        let currentPage = 1;
        const episodesPerPage = 25;

        if (type !== "anime") {
          if (tabsSection) tabsSection.style.display = "none";
          // NEW: Hide hero add button for non-anime types on this page
          if (addSeriesToListBtn) addSeriesToListBtn.style.display = "none";
        }

        function getSeriesIdFromUrl() {
          const params = new URLSearchParams(window.location.search);
          return params.get("id");
        }

        async function getKitsuId(malId) {
          try {
            const response = await fetch(`${serverUrl}/map/mal/${malId}`);
            if (!response.ok) throw new Error("Mapping API failed");
            const data = await response.json();
            return data.kitsu_id;
          } catch (error) {
            console.error(`Failed to map MAL ID ${malId} to Kitsu ID:`, error);
            return null;
          }
        }

        async function fetchKitsuData(kitsuId) {
          try {
            if (!kitsuId) return null;
            const response = await fetch(
              `https://kitsu.io/api/edge/anime/${kitsuId}`
            );
            if (!response.ok) throw new Error("Kitsu API failed");
            const data = await response.json();
            return data.data;
          } catch (error) {
            console.error(
              `Failed to fetch Kitsu data for ID ${kitsuId}:`,
              error
            );
            return null;
          }
        }

        async function fetchSeriesDetails(seriesId) {
          try {
            const response = await fetch(
              `https://api.jikan.moe/v4/${type}/${seriesId}/full`
            );
            if (!response.ok)
              throw new Error(
                `Jikan API error (details): ${response.status} ${response.statusText}`
              );
            const data = await response.json();
            return data.data;
          } catch (error) {
            console.error(`Failed to fetch ${type} details:`, error);
            displayError(
              "Could not load series details. Please try again later."
            );
          }
        }

        async function fetchSeriesEpisodes(kitsuId) {
          if (type !== "anime" || !kitsuId) return [];
          let allEpisodes = [];
          let url = `https://kitsu.io/api/edge/anime/${kitsuId}/episodes?page[limit]=20`;

          try {
            while (url) {
              const response = await fetch(url);
              if (!response.ok) {
                console.warn(
                  `Failed to fetch Kitsu episode page: ${response.status}`
                );
                break;
              }
              const data = await response.json();
              if (data.data && data.data.length > 0) {
                allEpisodes = allEpisodes.concat(data.data);
              }
              url = data.links?.next || null;
              if (url) await new Promise((resolve) => setTimeout(resolve, 200));
            }
            allEpisodes.sort(
              (a, b) => a.attributes.number - b.attributes.number
            );
            return allEpisodes;
          } catch (error) {
            console.error("Failed to fetch Kitsu episodes:", error);
            document.getElementById("tab-panel-episodes").innerHTML =
              '<p class="info-message">Could not load episodes.</p>';
            if (episodesLoader) episodesLoader.style.display = "none";
            return [];
          }
        }

        async function fetchSeriesEpisodesFromJikanVideos(malId) {
          if (type !== "anime" || !malId) return [];
          try {
            const response = await fetch(
              `https://api.jikan.moe/v4/anime/${malId}/videos`
            );
            if (!response.ok) {
              console.warn(`Failed to fetch Jikan videos: ${response.status}`);
              return [];
            }
            const data = await response.json();
            const episodes = data?.data?.episodes || [];

            // Adapt Jikan episode format to Kitsu-like format for compatibility
            return episodes
              .map((ep) => ({
                attributes: {
                  number: ep.mal_id,
                  canonicalTitle: ep.title,
                  seasonNumber: 1, // Jikan doesn't provide this, assume 1
                  thumbnail: {
                    small:
                      ep.images?.jpg?.image_url ||
                      "https://placehold.co/320x180/1f1f1f/FFF?text=?",
                  },
                },
              }))
              .sort((a, b) => a.attributes.number - b.attributes.number);
          } catch (error) {
            console.error(
              "Failed to fetch Jikan episodes from /videos endpoint:",
              error
            );
            return [];
          }
        }

        async function fetchRelations(seriesId) {
          try {
            const response = await fetch(
              `https://api.jikan.moe/v4/anime/${seriesId}/relations`
            );
            if (!response.ok)
              throw new Error(
                `Jikan API error (relations): ${response.status}`
              );
            const data = await response.json();
            return data.data;
          } catch (error) {
            console.error("Failed to fetch relations:", error);
            return [];
          }
        }

        async function fetchRecommendations(seriesId) {
          try {
            const response = await fetch(
              `https://api.jikan.moe/v4/anime/${seriesId}/recommendations`
            );
            if (!response.ok)
              throw new Error(
                `Jikan API error (recommendations): ${response.status}`
              );
            const data = await response.json();
            return data.data;
          } catch (error) {
            console.error("Failed to fetch recommendations:", error);
            return [];
          }
        }

        function cleanSynopsis(synopsis) {
          if (!synopsis) return "No synopsis available.";
          return synopsis.replace(/\[Written by MAL Rewrite\]/gi, "").trim();
        }

        async function getImage(malId) {
          try {
            const response = await fetch(
              `${serverUrl}/anime/image?mal_id=${malId}`
            );
            if (!response.ok) throw new Error("Failed to fetch MAL data");
            const data = await response.json();
            return data.image;
          } catch (error) {
            console.error("Failed to fetch MAL image:", error);
            return null;
          }
        }

        async function displayAnimeDetails(anime, kitsuData) {
          if (!anime) return;
          const customImage = await getImage(currentMalId).catch(() => null);
          const jikanImage =
            anime.images?.jpg?.large_image_url || anime.images?.jpg?.image_url;
          const heroImageUrl =
            customImage ||
            jikanImage ||
            "https://placehold.co/1200x700/141414/FFF?text=No+Image";

          heroSection.style.backgroundImage = `url('${heroImageUrl}')`;
          const displayTitle = anime.title_english || anime.title;
          currentSeriesTitle = displayTitle;
          seriesTitleTextElement.textContent = displayTitle;
          document.title = `${displayTitle} - Series Info`;
          seriesScoreElement.textContent = anime.score
            ? `Score: ${anime.score}`
            : "N/A";
          seriesYearElement.textContent = `${
            anime.year || anime.aired?.prop?.from?.year || "N/A"
          }`;
          seriesTypeElement.textContent = `${anime.type || "N/A"}`;
          seriesEpisodesCountElement.textContent = `${
            anime.episodes || "N/A"
          } Episodes`;
          seriesStatusElement.textContent = `${anime.status || "N/A"}`;
          seriesRatingElement.textContent = `${anime.rating || "N/A"}`;
          seriesSynopsisElement.innerHTML = cleanSynopsis(
            anime.synopsis
          ).replace(/\n/g, "<br>");
          seriesTitleEnglishElement.textContent = anime.title_english || "N/A";
          seriesTitleJapaneseElement.textContent =
            anime.title_japanese || "N/A";
          seriesSourceElement.textContent = anime.source || "N/A";
          seriesDurationElement.textContent = anime.duration || "N/A";
          seriesGenresContainer.innerHTML = "<strong>Genres:</strong> ";
          [
            ...anime.genres,
            ...(anime.explicit_genres || []),
            ...(anime.themes || []),
            ...(anime.demographics || []),
          ].forEach((g) => {
            const genreSpan = document.createElement("span");
            genreSpan.textContent = g.name;
            seriesGenresContainer.appendChild(genreSpan);
          });
          seriesStudiosContainer.innerHTML = "<strong>Studios:</strong> ";
          anime.studios.forEach((s) => {
            const studioSpan = document.createElement("span");
            studioSpan.textContent = s.name;
            seriesStudiosContainer.appendChild(studioSpan);
          });
          seriesProducersContainer.innerHTML = "<strong>Producers:</strong> ";
          anime.producers.forEach((p) => {
            const producerSpan = document.createElement("span");
            producerSpan.textContent = p.name;
            seriesProducersContainer.appendChild(producerSpan);
          });
          if (type === "anime" && kitsuData) {
            setupTrailerPlayer(kitsuData);
          }
        }

        function displayEpisodes(episodes) {
          if (episodesLoader) episodesLoader.style.display = "none";
          if (!episodes || episodes.length === 0) {
            document.getElementById("tab-panel-episodes").innerHTML =
              '<p class="info-message">No episodes found for this series.</p>';
            return;
          }
          episodesData = episodes;
          currentPage = 1;
          renderEpisodePage();
          setupPagination(episodesData.length);
        }

        async function displayRelations(relations) {
          relatedContainer.innerHTML = "";
          if (!relations || relations.length === 0) {
            relatedContainer.innerHTML =
              '<p class="info-message">No related content found.</p>';
            return;
          }

          relatedContainer.innerHTML =
            '<div class="episodes-loader" style="display: block;"></div>'; // Show loader

          const allEntries = relations.flatMap((rel) =>
            rel.entry.map((e) => ({ ...e, relation: rel.relation }))
          );

          const fetchKitsuPoster = async (entry) => {
            let poster = "https://placehold.co/80x120/1f1f1f/FFF?text=N/A";
            if (entry.type === "anime") {
              const kitsuId = await getKitsuId(entry.mal_id);
              const kitsuData = await fetchKitsuData(kitsuId);
              poster =
                kitsuData?.attributes?.posterImage?.small ||
                "https://placehold.co/80x120/1f1f1f/FFF?text=Anime";
            } else if (entry.type === "manga") {
              poster =
                `https://api.jikan.moe/v4/manga/${entry.mal_id}/pictures`.includes(
                  ".jpg"
                )
                  ? `https://api.jikan.moe/v4/manga/${entry.mal_id}/pictures`
                  : "https://placehold.co/80x120/1f1f1f/FFF?text=Manga";
            }
            return { ...entry, poster };
          };

          const entriesWithPosters = await Promise.all(
            allEntries.map(fetchKitsuPoster)
          );

          relatedContainer.innerHTML = ""; // Clear loader

          entriesWithPosters.forEach((entry) => {
            const card = document.createElement("a");
            card.className = "related-card";
            card.href = `series-info.html?id=${entry.mal_id}`;

            const displayTitle = entry.title_english || entry.name;
            card.title = displayTitle;

            const imgContainer = document.createElement("div");
            imgContainer.className = "related-card-img-container";

            const img = document.createElement("img");
            img.className = "related-card-img";
            img.src = entry.poster;
            img.alt = `Poster for ${displayTitle}`;
            img.loading = "lazy";
            imgContainer.appendChild(img);

            const infoDiv = document.createElement("div");
            infoDiv.className = "related-card-info";

            const title = document.createElement("h4");
            title.className = "related-card-title";
            title.textContent = displayTitle;

            const tag = document.createElement("span");
            tag.className = "related-card-tag";
            tag.textContent = entry.relation;

            infoDiv.appendChild(title);
            infoDiv.appendChild(tag);

            card.appendChild(imgContainer);
            card.appendChild(infoDiv);
            relatedContainer.appendChild(card);
          });
        }

        function displayRecommendations(recommendations) {
          recommendationsContainer.innerHTML = "";
          if (!recommendations || recommendations.length === 0) {
            recommendationsContainer.innerHTML =
              '<p class="info-message">No recommendations found.</p>';
            return;
          }

          recommendations.slice(0, 18).forEach((rec) => {
            const entry = rec.entry;
            const card = document.createElement("a");
            card.className = "recommendation-card";
            card.href = `series-info.html?id=${entry.mal_id}`;

            // Prioritize English title if available (though often not in this endpoint)
            const displayTitle = entry.title_english || entry.title;
            card.title = displayTitle;

            const imgContainer = document.createElement("div");
            imgContainer.className = "recommendation-card-img-container";

            const img = document.createElement("img");
            img.className = "recommendation-card-img";
            img.src =
              entry.images.jpg.large_image_url || entry.images.jpg.image_url;
            img.alt = `Poster for ${displayTitle}`;
            img.loading = "lazy";

            const title = document.createElement("div");
            title.className = "recommendation-card-title";
            title.textContent = displayTitle;

            imgContainer.appendChild(img);
            card.appendChild(imgContainer);
            card.appendChild(title);
            recommendationsContainer.appendChild(card);
          });
        }

        function loadLocalWatchHistory() {
          try {
            const history = localStorage.getItem("watch_history");
            localWatchHistory = history ? JSON.parse(history) : {};
          } catch (e) {
            console.error("Failed to parse local watch history", e);
            localWatchHistory = {};
          }
        }

        async function updateUserWatchHistoryOnApi(
          showId,
          showTitle,
          seasonNumber,
          episodeNumber
        ) {
          const token = localStorage.getItem("accessToken");
          if (!token) return;

          try {
            const params = new URLSearchParams({
              show_id: showId,
              show_title: showTitle,
              season_number: seasonNumber,
              episode_number: episodeNumber,
            });
            const response = await fetch(
              `${API_BASE_URL}/users/me/watch-history?${params.toString()}`,
              {
                method: "POST",
                headers: { Authorization: `Bearer ${token}` },
              }
            );
            if (!response.ok)
              throw new Error(`API update failed: ${response.status}`);
            console.log(
              `Successfully synced episode ${episodeNumber} for show ${showId} to API.`
            );
          } catch (error) {
            console.error("Failed to update user watch history on API:", error);
          }
        }

        function updateLocalWatchHistory(
          seriesId,
          seasonNumber,
          episodeNumber,
          seriesTitle
        ) {
          if (!seriesId || !episodeNumber) return;
          if (!localWatchHistory[seriesId])
            localWatchHistory[seriesId] = { seasons: {} };
          if (!localWatchHistory[seriesId].seasons[seasonNumber])
            localWatchHistory[seriesId].seasons[seasonNumber] = {
              episodes: {},
            };
          localWatchHistory[seriesId].seasons[seasonNumber].episodes[
            episodeNumber
          ] = { watched_at: new Date().toISOString() };
          try {
            localStorage.setItem(
              "watch_history",
              JSON.stringify(localWatchHistory)
            );
          } catch (e) {
            console.error("Failed to save local watch history", e);
          }
          updateUserWatchHistoryOnApi(
            seriesId,
            seriesTitle,
            seasonNumber,
            episodeNumber
          );
        }

        async function syncWatchHistory() {
          if (isSyncing) return;
          const token = localStorage.getItem("accessToken");
          if (!token) {
            console.log("No user token, skipping sync.");
            return;
          }
          isSyncing = true;
          console.log("Starting watch history sync...");
          try {
            const response = await fetch(`${API_BASE_URL}/users/me`, {
              headers: { Authorization: `Bearer ${token}` },
            });
            if (response.status === 401) {
              localStorage.removeItem("accessToken");
              isSyncing = false;
              return;
            }
            if (!response.ok) throw new Error(`API error: ${response.status}`);
            const userData = await response.json();
            const remoteHistory = userData.watch_history_detailed || {};
            userWatchHistory = remoteHistory;
            loadLocalWatchHistory();
            for (const showId in remoteHistory) {
              for (const seasonNum in remoteHistory[showId].seasons) {
                for (const epNum in remoteHistory[showId].seasons[seasonNum]
                  .episodes) {
                  if (!isEpisodeWatched(showId, seasonNum, epNum)) {
                    if (!localWatchHistory[showId])
                      localWatchHistory[showId] = { seasons: {} };
                    if (!localWatchHistory[showId].seasons[seasonNum])
                      localWatchHistory[showId].seasons[seasonNum] = {
                        episodes: {},
                      };
                    localWatchHistory[showId].seasons[seasonNum].episodes[
                      epNum
                    ] =
                      remoteHistory[showId].seasons[seasonNum].episodes[epNum];
                  }
                }
              }
            }
            localStorage.setItem(
              "watch_history",
              JSON.stringify(localWatchHistory)
            );
            const syncPromises = [];
            for (const showId in localWatchHistory) {
              if (showId !== currentMalId) continue;
              for (const seasonNum in localWatchHistory[showId].seasons) {
                for (const epNum in localWatchHistory[showId].seasons[seasonNum]
                  .episodes) {
                  if (
                    !remoteHistory[showId]?.seasons?.[seasonNum]?.episodes?.[
                      epNum
                    ]
                  ) {
                    console.log(
                      `Queueing upload for locally watched episode: Show ${showId}, S${seasonNum}, E${epNum}`
                    );
                    syncPromises.push(
                      updateUserWatchHistoryOnApi(
                        showId,
                        currentSeriesTitle,
                        seasonNum,
                        epNum
                      )
                    );
                  }
                }
              }
            }
            await Promise.all(syncPromises);
            console.log("Watch history sync complete.");
          } catch (error) {
            console.error(
              "An error occurred during watch history sync:",
              error
            );
          } finally {
            isSyncing = false;
            if (episodesData.length > 0) renderEpisodePage();
          }
        }

        function isEpisodeWatched(seriesId, seasonNumber, episodeNumber) {
          if (
            userWatchHistory &&
            userWatchHistory[seriesId]?.seasons?.[seasonNumber]?.episodes?.[
              episodeNumber
            ]
          )
            return true;
          if (
            localWatchHistory &&
            localWatchHistory[seriesId]?.seasons?.[seasonNumber]?.episodes?.[
              episodeNumber
            ]
          )
            return true;
          return false;
        }

        function renderEpisodePage() {
          episodeListContainer.innerHTML = "";
          const start = (currentPage - 1) * episodesPerPage;
          const end = start + episodesPerPage;
          const paginatedEpisodes = episodesData.slice(start, end);
          paginatedEpisodes.forEach((episode) => {
            const episodeItem = document.createElement("div");
            episodeItem.classList.add("episode-item");
            const episodeNumber = episode.attributes.number;
            const seasonNumber = episode.attributes.seasonNumber || 1;
            if (isEpisodeWatched(currentMalId, seasonNumber, episodeNumber))
              episodeItem.classList.add("watched");
            const episodeThumbnailDiv = document.createElement("div");
            episodeThumbnailDiv.className = "episode-thumbnail";
            const thumbnailImg = document.createElement("img");
            thumbnailImg.className = "episode-thumbnail-img";
            thumbnailImg.src =
              episode.attributes.thumbnail?.small ||
              "https://placehold.co/320x180/1f1f1f/FFF?text=?";
            thumbnailImg.loading = "lazy";
            episodeThumbnailDiv.appendChild(thumbnailImg);
            const episodeNumberSpan = document.createElement("span");
            episodeNumberSpan.classList.add("episode-number");
            episodeNumberSpan.textContent = episodeNumber;
            const episodeInfoDiv = document.createElement("div");
            episodeInfoDiv.classList.add("episode-info");
            const episodeTitle = document.createElement("h4");
            episodeTitle.classList.add("episode-title");
            episodeTitle.textContent =
              episode.attributes.canonicalTitle || `Episode ${episodeNumber}`;
            episodeInfoDiv.appendChild(episodeTitle);

            // Action buttons container
            const actionBtnsDiv = document.createElement("div");
            actionBtnsDiv.className = "episode-action-buttons";

            // Download Button
            const downloadBtn = document.createElement("button");
            downloadBtn.className = "glassy-download-btn episode-action-icon";
            downloadBtn.title = "Download Episode";
            downloadBtn.innerHTML = '<i class="fas fa-cloud-download"></i>';
            downloadBtn.addEventListener("click", (event) => {
              event.stopPropagation();
              let quality = localStorage.getItem("quality") || "720p";
              const isDub = true;
              window.open(
                `${serverUrl}/download?mal_id=${currentMalId}&episode=${episodeNumber}&dub=${isDub}&quality=${quality}`,
                "_blank"
              );
            });

            // NEW: Add to List Button
            const addToListBtn = document.createElement("button");
            addToListBtn.className = "glassy-download-btn episode-action-icon";
            addToListBtn.title = "Add to List";
            addToListBtn.innerHTML = '<i class="fas fa-plus-square"></i>';
            addToListBtn.addEventListener("click", (event) => {
              event.stopPropagation();
              if (
                window.parent &&
                typeof window.parent.openListManager === "function"
              ) {
                window.parent.openListManager({
                  type: "anime",
                  id: currentMalId,
                  title: currentSeriesTitle,
                  items: [String(episodeNumber)], // Send as array of strings
                  source: "jikan",
                });
              }
            });

            actionBtnsDiv.appendChild(addToListBtn);
            actionBtnsDiv.appendChild(downloadBtn);

            episodeItem.appendChild(episodeThumbnailDiv);
            episodeItem.appendChild(episodeNumberSpan);
            episodeItem.appendChild(episodeInfoDiv);
            episodeItem.appendChild(actionBtnsDiv);
            episodeItem.addEventListener("click", (event) => {
              if (event.target.closest(".episode-action-icon")) return;
              episodeItem.classList.add("watched");
              updateLocalWatchHistory(
                currentMalId,
                seasonNumber,
                episodeNumber,
                currentSeriesTitle
              );
              const refererUrl = encodeURIComponent(window.location.href);
              const url = `view.html?id=${encodeURIComponent(
                currentMalId
              )}&ep=${encodeURIComponent(episodeNumber)}&referer=${refererUrl}`;
              openEpisodePopup(url);
            });
            episodeListContainer.appendChild(episodeItem);
          });
        }

        async function setupTrailerPlayer(kitsuData) {
          const trailerSection = document.getElementById("trailer-section");
          const trailerPlayer = document.getElementById("trailer-player");
          if (!kitsuData || !kitsuData.attributes.youtubeVideoId) {
            trailerSection.style.display = "none";
            return;
          }
          const youtubeId = kitsuData.attributes.youtubeVideoId;
          try {
            trailerSection.style.display = "block";
            const isMobile =
              /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent
              );
            if (isMobile) {
              trailerPlayer.innerHTML = `<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; background: var(--background-tertiary);"><iframe src="https://www.youtube.com/embed/${youtubeId}?rel=0&modestbranding=1&playsinline=1&enablejsapi=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen title="Anime Trailer"></iframe></div>`;
            } else {
              try {
                csPlayer.init("trailer-player", {
                  defaultId: youtubeId,
                  thumbnail: true,
                  theme: "default",
                  loop: false,
                  autoplay: false,
                });
              } catch (csPlayerError) {
                console.warn(
                  "csPlayer failed, falling back to iframe:",
                  csPlayerError
                );
                trailerPlayer.innerHTML = `<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; background: var(--background-tertiary);"><iframe src="https://www.youtube.com/embed/${youtubeId}?rel=0&modestbranding=1&enablejsapi=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen title="Anime Trailer"></iframe></div>`;
              }
            }
            console.log(`Trailer loaded for YouTube ID: ${youtubeId}`);
          } catch (error) {
            console.error("Failed to initialize trailer player:", error);
            trailerPlayer.innerHTML = `<div class="no-trailer-message" style="text-align: center; padding: 2rem;"><p style="margin-bottom: 1rem; color: var(--text-muted);">Trailer available on YouTube</p><a href="https://www.youtube.com/watch?v=${youtubeId}" target="_blank" style="display: inline-block; padding: 0.75rem 1.5rem; background: var(--brand-accent); color: var(--background-primary); text-decoration: none; border-radius: 6px; font-weight: 500;"><i class="fab fa-youtube" style="margin-right: 0.5rem;"></i> Watch on YouTube</a></div>`;
          }
        }

        function setupPagination(totalEpisodes) {
          episodesPaginationContainer.innerHTML = "";
          const pageCount = Math.ceil(totalEpisodes / episodesPerPage);
          if (pageCount <= 1) return;
          const prevButton = document.createElement("button");
          prevButton.innerHTML = "« Prev";
          prevButton.disabled = currentPage === 1;
          prevButton.addEventListener("click", () => {
            if (currentPage > 1) {
              currentPage--;
              renderEpisodePage();
              updatePaginationButtons(pageCount);
              window.scrollTo(
                0,
                document.getElementById("tabs-section").offsetTop
              );
            }
          });
          episodesPaginationContainer.appendChild(prevButton);
          const pageInfo = document.createElement("span");
          pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
          episodesPaginationContainer.appendChild(pageInfo);
          const nextButton = document.createElement("button");
          nextButton.innerHTML = "Next »";
          nextButton.disabled = currentPage === pageCount;
          nextButton.addEventListener("click", () => {
            if (currentPage < pageCount) {
              currentPage++;
              renderEpisodePage();
              updatePaginationButtons(pageCount);
              window.scrollTo(
                0,
                document.getElementById("tabs-section").offsetTop
              );
            }
          });
          episodesPaginationContainer.appendChild(nextButton);
        }

        function updatePaginationButtons(pageCount) {
          const prevButton =
            episodesPaginationContainer.querySelector("button:first-child");
          const nextButton =
            episodesPaginationContainer.querySelector("button:last-child");
          const pageInfo = episodesPaginationContainer.querySelector("span");
          if (prevButton) prevButton.disabled = currentPage === 1;
          if (nextButton) nextButton.disabled = currentPage === pageCount;
          if (pageInfo)
            pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
        }

        function displayError(message) {
          const mainContent = document.querySelector(".series-main-content");
          if (mainContent)
            mainContent.innerHTML = `<p class="error-message" style="color: #ff6b6b; text-align: center; padding: 30px; font-size: 1.2em;">${message}</p>`;
          if (heroSection) heroSection.style.display = "none";
          if (backButton && message.includes("No series ID specified"))
            backButton.style.display = "none";
        }

        function setupThumbnailToggle() {
          const storageKey = "showEpisodeThumbnails";
          let showThumbnails = localStorage.getItem(storageKey) !== "false";
          function applyPreference() {
            if (showThumbnails) {
              episodeListContainer.classList.remove("thumbnails-hidden");
              thumbnailToggleBtn.classList.add("active");
            } else {
              episodeListContainer.classList.add("thumbnails-hidden");
              thumbnailToggleBtn.classList.remove("active");
            }
          }
          thumbnailToggleBtn.addEventListener("click", () => {
            showThumbnails = !showThumbnails;
            localStorage.setItem(storageKey, showThumbnails);
            applyPreference();
          });
          applyPreference();
        }

        function setupTabs() {
          tabsContainer.addEventListener("click", (e) => {
            const targetTab = e.target.closest(".tab-btn");
            if (!targetTab) return;

            tabsContainer
              .querySelectorAll(".tab-btn")
              .forEach((btn) => btn.classList.remove("active"));
            tabPanels.forEach((panel) => panel.classList.remove("active"));

            targetTab.classList.add("active");
            const tabName = targetTab.dataset.tab;
            const activePanel = document.getElementById(`tab-panel-${tabName}`);
            if (activePanel) {
              activePanel.classList.add("active");
            }
          });
        }

        async function fetchAndDisplaySeasons(malId) {
            try {
                const response = await fetch(`${serverUrl}/anime/${malId}/seasons`);
                if (!response.ok) throw new Error('Failed to fetch seasons');
                const seasons = await response.json();

                if (seasons && seasons.length > 1) {
                    seasonSelector.innerHTML = '';
                    seasons.forEach((season, index) => {
                        const option = document.createElement('option');
                        option.value = season.mal_id;
                        const seasonLabel = `Season ${index + 1}`;
                        option.textContent = `${seasonLabel}: ${season.title}`;
                        option.dataset.fullTitle = season.title;

                        if (String(season.mal_id) === String(malId)) {
                            option.selected = true;
                        }
                        seasonSelector.appendChild(option);
                    });
                    seasonSelectorContainer.style.display = 'block';
                } else {
                    seasonSelectorContainer.style.display = 'none';
                }
            } catch (error) {
                console.error("Failed to load seasons:", error);
                seasonSelectorContainer.style.display = 'none';
            }
        }

        seasonSelector.addEventListener('change', async (event) => {
            const newMalId = event.target.value;
            if (newMalId === currentMalId) return;

            currentMalId = newMalId;
            
            const selectedOption = seasonSelector.options[seasonSelector.selectedIndex];
            currentSeriesTitle = selectedOption.dataset.fullTitle;

            episodeListContainer.innerHTML = '';
            episodesPaginationContainer.innerHTML = '';
            if (episodesLoader) episodesLoader.style.display = 'block';

            let newEpisodes = [];
            const newKitsuId = await getKitsuId(currentMalId);
            if (newKitsuId) {
                newEpisodes = await fetchSeriesEpisodes(newKitsuId);
            }
            if (!newEpisodes || newEpisodes.length === 0) {
                newEpisodes = await fetchSeriesEpisodesFromJikanVideos(currentMalId);
            }
            displayEpisodes(newEpisodes);
        });

        function setupCollapsibleDetails() {
          // Use a timeout to ensure content has rendered and scrollHeight is accurate
          setTimeout(() => {
            const collapsedHeight = parseInt(
              window.getComputedStyle(detailsWrapper).maxHeight,
              10
            );
            // Check if content is overflowing, with a buffer
            if (detailsWrapper.scrollHeight > collapsedHeight + 50) {
              showMoreContainer.style.display = "block";

              showMoreBtn.addEventListener("click", () => {
                const isExpanded = detailsWrapper.classList.toggle("expanded");
                showMoreBtnText.textContent = isExpanded
                  ? "Show Less"
                  : "Show More";
              });
            } else {
              // If no overflow, remove the fade effect and the button container itself.
              detailsWrapper.style.maxHeight = "none";
              detailsWrapper.classList.add("expanded"); // This removes the ::after pseudo-element
              showMoreContainer.style.display = "none";
            }
          }, 800); // Delay to allow images/trailer to load and affect scrollHeight
        }

        async function handleEpisodeToWatchOnLoad(episodeToWatch) {
          if (!episodeToWatch || !episodesData.length) return;
          const episodeNumberToFind = parseInt(episodeToWatch, 10);
          if (isNaN(episodeNumberToFind)) return;
          const episodeIndex = episodesData.findIndex(
            (ep) => ep.attributes.number === episodeNumberToFind
          );
          if (episodeIndex > -1) {
            const episode = episodesData[episodeIndex];
            const seasonNumber = episode.attributes.seasonNumber || 1;
            const openPlayer = () => {
              const targetPage = Math.ceil(
                (episodeIndex + 1) / episodesPerPage
              );
              if (currentPage !== targetPage) {
                currentPage = targetPage;
                renderEpisodePage();
                updatePaginationButtons(
                  Math.ceil(episodesData.length / episodesPerPage)
                );
              }
              updateLocalWatchHistory(
                currentMalId,
                seasonNumber,
                episodeNumberToFind,
                currentSeriesTitle
              );
              const episodeItems =
                episodeListContainer.querySelectorAll(".episode-item");
              const itemIndexOnPage = episodeIndex % episodesPerPage;
              if (episodeItems[itemIndexOnPage])
                episodeItems[itemIndexOnPage].classList.add("watched");
              const refererUrl = encodeURIComponent(
                window.location.href.split("&watch-ep=")[0]
              );
              const url = `view.html?id=${encodeURIComponent(
                currentMalId
              )}&ep=${encodeURIComponent(
                episodeNumberToFind
              )}&referer=${refererUrl}`;
              openEpisodePopup(url);
            };
            if (
              isEpisodeWatched(currentMalId, seasonNumber, episodeNumberToFind)
            ) {
              showConfirmation(
                "You've already seen this episode. Do you want to watch it again?",
                openPlayer
              );
            } else {
              openPlayer();
            }
          }
        }

        // NEW: Event listener for hero "Add to List" button
        if (addSeriesToListBtn) {
          addSeriesToListBtn.addEventListener("click", () => {
            if (type === "anime" && episodesData.length > 0) {
              const allEpisodeNumbers = episodesData.map((ep) =>
                String(ep.attributes.number)
              );
              if (
                window.parent &&
                typeof window.parent.openListManager === "function"
              ) {
                window.parent.openListManager({
                  type: "anime",
                  id: currentMalId,
                  title: currentSeriesTitle,
                  items: allEpisodeNumbers,
                  source: "jikan",
                });
              }
            }
          });
        }

        // NEW: Event listener for hero "Export" button
        const exportSeriesBtn = document.getElementById("export-series-btn");
        if (exportSeriesBtn) {
          exportSeriesBtn.addEventListener("click", () => {
            if (!currentMalId || !type) {
              window.parent.showToast("Series information not loaded yet.");
              return;
            }
            const serverIp = localStorage.getItem("extension_server_ip");
            if (!serverIp) {
              window.parent.showToast("Server IP not configured.");
              return;
            }
            const serverUrl = `http://${serverIp}:7275`;
            const exportUrl = `${serverUrl}/export/series/${currentMalId}?type=${type}`;

            window.open(exportUrl, "_blank");
          });
        }

        async function init() {
          const params = new URLSearchParams(window.location.search);
          currentMalId = params.get("id");
          // In the init() function, right after setting up toggles and tabs
          const profileId = localStorage.getItem("currentProfileId");
          if (profileId) {
            try {
              // const response = await fetch(`/profiles/${profileId}`);
              const response = await fetch(`/profiles/${profileId}`);
              if (response.ok) {
                currentProfile = await response.json();
              } else {
                console.warn(
                  "Could not fetch current profile. Watch history will be disabled."
                );
              }
            } catch (e) {
              console.error("Error fetching profile:", e);
            }
          }
          const episodeToWatchOnLoad = params.get("watch-ep");
          if (!currentMalId) {
            displayError(
              "No series ID specified in the URL. Example: series-info.html?id=5114"
            );
            return;
          }

          setupThumbnailToggle();
          setupTabs();
          loadLocalWatchHistory();

          const seriesDetails = await fetchSeriesDetails(currentMalId);

          if (seriesDetails) {
            await syncWatchHistory();

            if (type === "anime") {
              if (tabsSection) tabsSection.style.display = "block";

              currentKitsuId = await getKitsuId(currentMalId);
              const kitsuData = await fetchKitsuData(currentKitsuId);

              await displayAnimeDetails(seriesDetails, kitsuData);
              await fetchAndDisplaySeasons(currentMalId);
              setupCollapsibleDetails();

              if (episodesLoader) episodesLoader.style.display = "block";

              let episodes = [];
              if (currentKitsuId) {
                episodes = await fetchSeriesEpisodes(currentKitsuId);
              }

              if (!episodes || episodes.length === 0) {
                // Fallback to Jikan
                console.log(
                  "Kitsu episodes not found, falling back to Jikan..."
                );
                episodes = await fetchSeriesEpisodesFromJikanVideos(
                  currentMalId
                );
                if (episodes && episodes.length > 0) {
                  // Display a message to the user
                  const episodeListSection = document.querySelector(
                    ".episode-list-section"
                  );
                  if (episodeListSection) {
                    const warning = document.createElement("p");
                    warning.textContent =
                      "Episode data is from a fallback source and may be incomplete.";
                    warning.className = "info-message fallback-warning";
                    episodeListSection.prepend(warning);
                  }
                }
              }

              const [relations, recommendations] = await Promise.all([
                fetchRelations(currentMalId),
                fetchRecommendations(currentMalId),
              ]);

              displayEpisodes(episodes);
              displayRelations(relations);
              displayRecommendations(recommendations);

              if (episodeToWatchOnLoad)
                await handleEpisodeToWatchOnLoad(episodeToWatchOnLoad);
            } else {
              // Manga logic
              if (tabsSection) tabsSection.style.display = "none";
              await displayAnimeDetails(seriesDetails, null);
              setupCollapsibleDetails();
            }
          }
        }

        // --- POPUP OVERLAY LOGIC ---
        const popupOverlay = document.getElementById("episode-popup-overlay");
        const popupIframe = document.getElementById("episode-popup-iframe");
        function openEpisodePopup(url) {
          popupIframe.src = url;
          popupOverlay.style.display = "flex";
          setTimeout(() => popupOverlay.classList.add("active"), 10);
          document.body.style.overflow = "hidden";
        }
        function closeEpisodePopup() {
          popupOverlay.classList.remove("active");
          setTimeout(() => {
            popupOverlay.style.display = "none";
            popupIframe.src = "";
            document.body.style.overflow = "";
          }, 300);
        }
        const popupBackBtn = popupOverlay.querySelector(".episode-popup-back");
        popupBackBtn.addEventListener("click", closeEpisodePopup);
        popupOverlay.addEventListener("click", (e) => {
          if (e.target === popupOverlay) closeEpisodePopup();
        });

        // --- CONFIRMATION POPUP LOGIC ---
        const confirmOverlay = document.getElementById(
          "confirmation-popup-overlay"
        );
        const confirmMessage = document.getElementById(
          "confirmation-popup-message"
        );
        const confirmBtn = document.getElementById("confirm-btn");
        const cancelBtn = document.getElementById("cancel-btn");
        let confirmCallback = null;
        function showConfirmation(message, onConfirm) {
          confirmMessage.textContent = message;
          confirmCallback = onConfirm;
          confirmOverlay.style.display = "flex";
          setTimeout(() => confirmOverlay.classList.add("active"), 10);
          document.body.style.overflow = "hidden";
        }
        function closeConfirmation() {
          confirmOverlay.classList.remove("active");
          setTimeout(() => {
            confirmOverlay.style.display = "none";
            document.body.style.overflow = "";
          }, 300);
        }
        confirmBtn.addEventListener("click", () => {
          if (confirmCallback) confirmCallback();
          closeConfirmation();
        });
        cancelBtn.addEventListener("click", closeConfirmation);
        confirmOverlay.addEventListener("click", (e) => {
          if (e.target === confirmOverlay) closeConfirmation();
        });

        init();
      });
    </script>
  </body>
</html>
