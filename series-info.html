<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Series Info - Media App</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<!-- Add after the existing font-awesome link -->
<link rel="stylesheet" href="https://abtp2.github.io/csPlayer/src/csPlayer.css">
<script src="https://www.youtube.com/iframe_api"></script>
<style>
    /* --- CSS RESET & BASE STYLES --- */
    :root {
        --brand-accent: #ff9500;
        --background-primary: #000000;
        --background-secondary: #141414;
        --background-tertiary: #1f1f1f;
        --text-primary: #ffffff;
        --text-secondary: #e5e5e5;
        --text-muted: #a0a0a0;
        --border-color: #2a2a2a;
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    html {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    body {
        background-color: var(--background-primary);
        color: var(--text-primary);
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    /* Custom Dark Scrollbar */
    ::-webkit-scrollbar {
        width: 10px;
    }
    ::-webkit-scrollbar-track {
        background: var(--background-secondary);
    }
    ::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    /* --- APP STRUCTURE --- */
    .app-container {
        width: 100%;
        min-height: 100vh;
    }

    /* --- HEADER & HERO SECTION --- */
    .series-hero-section {
        position: relative;
        height: 65vh;
        min-height: 400px;
        background-size: cover;
        background-position: center 20%;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        padding: 2rem 4%;
        box-shadow: 0 10px 30px -15px rgba(0,0,0,0.5);
    }

    .hero-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(to top, rgba(0,0,0,1) 10%, rgba(0,0,0,0.8) 40%, rgba(0,0,0,0) 80%);
        z-index: 1;
    }
    
    .series-hero-content {
        position: relative;
        z-index: 2;
        max-width: 50%;
    }

    .series-title-text {
        font-size: clamp(2rem, 5vw, 4rem);
        font-weight: 700;
        color: var(--text-primary);
        text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
        line-height: 1.1;
    }

    .back-btn {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-primary);
        width: 44px;
        height: 44px;
        border-radius: 50%;
        font-size: 1.2rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease, transform 0.2s ease;
    }

    .back-btn:hover {
        background-color: rgba(255, 255, 255, 0.15);
        transform: scale(1.05);
    }

    /* --- MAIN CONTENT & SERIES DETAILS --- */
    .main-content {
        padding: 2rem 4%;
        background-color: var(--background-primary);
    }

    .series-details-section {
        max-width: 1400px;
        margin: 0 auto 2rem;
    }
    
    .series-meta-info {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px 16px;
        color: var(--text-muted);
        margin-bottom: 1.5rem;
        font-size: 0.9rem;
    }
    
    /* ****** START: COLLAPSIBLE DETAILS CSS ****** */
    .details-content-wrapper {
        position: relative;
        max-height: 450px; /* Adjust this value to control collapsed height */
        overflow: hidden;
        transition: max-height 0.5s ease-in-out;
    }
    .details-content-wrapper::after { /* The fade-out effect */
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 150px;
        background: linear-gradient(to top, var(--background-primary) 20%, transparent);
        pointer-events: none;
        transition: opacity 0.3s ease;
    }

    .details-content-wrapper.expanded {
        max-height: 5000px; /* Large enough value to fit any content */
    }
    .details-content-wrapper.expanded::after {
        opacity: 0;
    }
    
    .details-grid {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 2.5rem;
        margin-bottom: 2rem;
    }

    .show-more-container {
        text-align: center;
        padding-top: 1rem;
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 2rem;
        margin-bottom: 2rem;
    }

    .show-more-btn {
        background: var(--background-tertiary);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        padding: 0.75rem 1.5rem;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .show-more-btn:hover {
        background-color: #333;
        border-color: #555;
    }
    .show-more-btn i {
        margin-left: 8px;
        transition: transform 0.3s ease;
    }
    .details-content-wrapper.expanded + .show-more-container .show-more-btn i {
        transform: rotate(180deg);
    }
     /* ****** END: COLLAPSIBLE DETAILS CSS ****** */
    
    #series-score {
        font-weight: 600;
        color: var(--text-secondary);
    }
    
    #series-synopsis {
        font-size: 1rem;
        line-height: 1.6;
        color: var(--text-secondary);
        margin-bottom: 1.5rem;
    }
    
    #series-info-additional {
        font-size: 0.9rem;
        color: var(--text-muted);
        line-height: 1.7;
    }
    #series-info-additional strong {
        color: var(--text-secondary);
        font-weight: 500;
    }

    .series-genres, .series-studios, .series-producers {
        margin-top: 1rem;
        font-size: 0.9rem;
    }
    .series-genres strong, .series-studios strong, .series-producers strong {
        color: var(--text-muted);
        font-weight: 500;
        margin-right: 8px;
    }
    .series-genres span, .series-studios span, .series-producers span {
        display: inline-block;
        margin: 4px 4px 0 0;
        padding: 4px 10px;
        background-color: var(--background-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-secondary);
    }
    .series-genres span:hover, .series-studios span:hover, .series-producers span:hover {
        background-color: #333;
    }
    
    /* ****** START: TABS SYSTEM CSS ****** */
    .tabs-section {
        margin-top: 3rem;
        max-width: 1400px;
        margin-left: auto;
        margin-right: auto;
    }

    .tabs-container {
        display: flex;
        gap: 1rem;
        border-bottom: 2px solid var(--border-color);
        margin-bottom: 2rem;
    }
    
    .tab-btn {
        padding: 1rem 0.5rem;
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--text-muted);
        background: none;
        border: none;
        cursor: pointer;
        position: relative;
        transition: color 0.2s ease;
    }

    .tab-btn::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 0;
        right: 0;
        height: 2px;
        background-color: var(--brand-accent);
        transform: scaleX(0);
        transition: transform 0.3s ease;
    }

    .tab-btn:hover {
        color: var(--text-primary);
    }
    
    .tab-btn.active {
        color: var(--text-primary);
    }
    .tab-btn.active::after {
        transform: scaleX(1);
    }
    
    .tab-panel {
        display: none;
    }
    .tab-panel.active {
        display: block;
    }

    /* ****** END: TABS SYSTEM CSS ****** */


    /* --- EPISODE LIST --- */
    .episode-list-section {
        /* No longer a primary section, just a container inside a tab */
    }
    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        border-bottom: 3px solid var(--background-tertiary);
        padding-bottom: 10px;
    }
    .section-title {
        font-size: 1.75rem;
        font-weight: 600;
        color: var(--text-secondary);
        margin: 0;
        padding: 0;
        border: none;
    }

    .thumbnail-toggle-btn {
        background-color: var(--background-tertiary);
        color: var(--text-muted);
        border: 1px solid var(--border-color);
        width: 40px;
        height: 40px;
        border-radius: 8px;
        font-size: 1.2rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }
    .thumbnail-toggle-btn:hover {
        color: var(--text-secondary);
        border-color: #444;
    }
    .thumbnail-toggle-btn.active {
        color: var(--background-primary);
        background-color: var(--brand-accent);
        border-color: var(--brand-accent);
    }

    /* ****** START: LOADING BAR CSS ****** */
    .episodes-loader {
        width: 100%;
        height: 4px;
        background-color: var(--background-tertiary);
        border-radius: 2px;
        margin-bottom: 1.5rem;
        overflow: hidden;
        position: relative;
        display: none; /* Hidden by default */
    }

    .episodes-loader::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        background: linear-gradient(90deg, transparent, var(--brand-accent), transparent);
        animation: loading-shimmer 1.5s infinite linear;
    }

    @keyframes loading-shimmer {
        0% {
            transform: translateX(-100%);
        }
        100% {
            transform: translateX(100%);
        }
    }
    /* ****** END: LOADING BAR CSS ****** */

    .episode-list {
        border-radius: 8px;
        overflow: hidden;
        background-color: var(--background-secondary);
    }
    .episode-item {
        display: flex;
        align-items: center;
        gap: 1.5rem;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid var(--border-color);
        transition: background-color 0.2s ease;
        cursor: pointer;
    }
    .episode-item:last-child {
        border-bottom: none;
    }
    .episode-item:hover {
        background-color: var(--background-tertiary);
    }

    .episode-thumbnail {
        flex-shrink: 0;
        width: 120px;
        height: 68px;
        overflow: hidden;
        border-radius: 6px;
        background-color: var(--background-tertiary);
        transition: width 0.3s ease;
    }
    .episode-thumbnail-img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    .episode-list.thumbnails-hidden .episode-thumbnail {
        width: 0;
        margin-right: -1.5rem; /* collapse gap */
    }
    .episode-list.thumbnails-hidden .episode-item {
        gap: 1.5rem;
    }

    .episode-number {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-muted);
        flex-shrink: 0;
        width: 40px;
        text-align: center;
    }
    
    .episode-info {
        flex-grow: 1;
        min-width: 0; /* Fix for flexbox text overflow */
    }
    .episode-title {
        font-size: 1.1rem;
        font-weight: 500;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .episode-title-romanji {
        font-size: 0.9rem;
        color: var(--text-muted);
        margin-top: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* --- WATCHED EPISODE STYLES --- */
    .episode-item.watched {
        background: rgba(255, 149, 0, 0.05);
        border-left: 4px solid var(--brand-accent);
        padding-left: calc(1.5rem - 4px); /* Adjust padding to account for border */
    }
    .episode-item.watched .episode-number {
        color: var(--brand-accent);
    }
    .episode-item.watched:hover {
        background: rgba(255, 149, 0, 0.1);
    }
    
    .watched-indicator {
        color: var(--brand-accent);
        font-size: 0.9em;
    }

    /* --- PAGINATION --- */
    .episodes-pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        margin-top: 2rem;
    }
    .episodes-pagination button {
        background-color: var(--background-tertiary);
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
        padding: 0.5rem 1rem;
        border-radius: 6px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s ease, color 0.2s ease;
    }
    .episodes-pagination button:hover:not(:disabled) {
        background-color: var(--brand-accent);
        color: var(--background-primary);
        border-color: var(--brand-accent);
    }
    .episodes-pagination button:disabled {
        background-color: #1a1a1a;
        color: #555;
        cursor: not-allowed;
        border-color: #222;
    }
    .episodes-pagination span {
        color: var(--text-muted);
    }
    
    /* ****** START: RELATED & RECOMMENDATIONS CSS ****** */
    .content-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 1.5rem;
    }
    
    .recommendation-card {
        background-color: var(--background-secondary);
        border-radius: 8px;
        overflow: hidden;
        text-decoration: none;
        color: var(--text-primary);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        display: flex;
        flex-direction: column;
    }
    .recommendation-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 20px rgba(0,0,0,0.4);
    }
    
    .recommendation-card-img-container {
        width: 100%;
        aspect-ratio: 2 / 3;
        background-color: var(--background-tertiary);
    }

    .recommendation-card-img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .recommendation-card-title {
        font-size: 0.9rem;
        font-weight: 500;
        padding: 0.75rem;
        flex-grow: 1;
        line-height: 1.4;
    }
    
    .related-card {
        display: flex;
        gap: 1rem;
        background-color: var(--background-secondary);
        border-radius: 8px;
        margin-bottom: 1rem;
        overflow: hidden;
        text-decoration: none;
        transition: background-color 0.2s ease;
    }
    .related-card:hover {
        background-color: var(--background-tertiary);
    }

    .related-card-img-container {
        flex-shrink: 0;
        width: 80px;
        aspect-ratio: 2/3;
        background-color: var(--background-tertiary);
    }
    .related-card-img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    .related-card-info {
        flex-grow: 1;
        padding: 1rem 1rem 1rem 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        min-width: 0; /* Fix flexbox overflow */
    }
    .related-card-title {
        font-size: 1.1rem;
        font-weight: 500;
        color: var(--text-primary);
        margin-bottom: 0.5rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .related-card-tag {
        font-size: 0.8rem;
        font-weight: 600;
        text-transform: capitalize;
        color: var(--background-primary);
        background-color: var(--brand-accent);
        padding: 4px 8px;
        border-radius: 4px;
        align-self: flex-start;
    }

    .info-message {
        padding: 2rem;
        text-align: center;
        color: var(--text-muted);
        font-style: italic;
    }

    /* ****** END: RELATED & RECOMMENDATIONS CSS ****** */


    /* --- RESPONSIVE ADJUSTMENTS --- */
    @media (max-width: 768px) {
        .series-details-section {
            /* No longer a grid */
        }
        .details-grid {
            grid-template-columns: 1fr;
        }
        .series-hero-content {
            max-width: 100%;
        }
        .main-content, .series-hero-section {
            padding: 1.5rem 5%;
        }
        .episode-item {
            padding: 0.75rem 1rem;
            gap: 1rem;
        }
        .episode-title {
            font-size: 1rem;
        }
        .episode-number {
            font-size: 1.25rem;
        }
        .episode-thumbnail {
            width: 90px;
            height: 51px;
        }
        .tab-btn {
            font-size: 1.1rem;
        }
        .content-grid {
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 1rem;
        }
        .related-card-title {
            font-size: 1rem;
        }
    }
    
    /* --- USER-PROVIDED STYLES (INTEGRATED & THEMED) --- */
    .glassy-download-btn {
        margin-top: 5px;
        font-size: 1.5em;
        font-weight: 600;
        color: #fff;
        background: rgba(255,255,255,0.1);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 18px;
        backdrop-filter: blur(8px);
        transition: background 0.2s;
        cursor: pointer;
        outline: none;
        margin-left: -20px;
    }
    .glassy-download-btn:hover {
        background: rgba(255,255,255,0.2);
    }

    .episode-download-icon {
        background: none !important;
        border: none !important;
        box-shadow: none !important;
        padding: 0 !important;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background 0.2s;
        flex-shrink: 0;
    }
    .episode-download-icon i {
        color: var(--text-muted);
        font-size: 0.8em;
        pointer-events: none;
        transition: color 0.2s;
    }
    .episode-item:hover .episode-download-icon i {
        color: var(--text-secondary);
    }
    .episode-download-icon:hover i {
        color: var(--brand-accent) !important;
    }

    /* --- EPISODE POPUP OVERLAY --- */
    .episode-popup-overlay {
        position: fixed;
        z-index: 9999;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.3s ease;
        opacity: 0;
        pointer-events: none;
    }
    .episode-popup-overlay.active {
        opacity: 1;
        pointer-events: auto;
    }
    
    .episode-popup-content {
        position: relative;
        width: clamp(300px, 95vw, 1400px);
        height: auto;
        aspect-ratio: 16 / 9;
        background: var(--background-primary);
        border-radius: 12px;
        box-shadow: 0 10px 50px rgba(0,0,0,0.5);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transform: scale(0.95);
        transition: transform 0.3s ease;
    }
    .episode-popup-overlay.active .episode-popup-content {
        transform: scale(1);
    }

    .episode-popup-back {
        position: absolute;
        top: 1rem;
        left: 1rem;
        z-index: 2;
        font-size: 1.2em;
        color: #fff;
        background: rgba(0, 0, 0, 0.5);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s;
    }
    .episode-popup-back:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.1);
    }

    .episode-popup-content iframe {
        flex-grow: 1;
        width: 100%;
        height: 100%;
        border: none;
        background: var(--background-primary);
    }
    
    @media (max-width: 900px) {
        .episode-popup-content {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            aspect-ratio: unset;
        }
    }
    /* Add these styles to the existing <style> section */
    .trailer-section {
        /* margin-top is handled by details-grid gap */
        max-width: 1400px;
        margin-left: auto;
        margin-right: auto;
    }

    .trailer-player-container {
        background-color: var(--background-secondary);
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 2rem;
    }

    .trailer-title {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-secondary);
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .trailer-title i {
        color: var(--brand-accent);
    }

    #trailer-player {
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        border-radius: 8px;
        overflow: hidden;
        background-color: var(--background-tertiary);
        /* Ensure proper aspect ratio on all devices */
        min-height: 200px;
    }

    .no-trailer-message {
        text-align: center;
        color: var(--text-muted);
        padding: 2rem;
        font-style: italic;
    }

    /* Mobile-specific trailer improvements */
    @media (max-width: 768px) {
        .trailer-player-container {
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 8px;
        }
        
        .trailer-title {
            font-size: 1.3rem;
        }
        
        #trailer-player {
            border-radius: 6px;
            min-height: 180px;
        }
        
        /* Ensure YouTube iframe is touch-friendly on mobile */
        #trailer-player iframe {
            min-height: 200px;
        }
    }

    /* Improve touch targets for mobile */
    @media (max-width: 480px) {
        .trailer-player-container {
            margin: 0.5rem 0;
            padding: 0.75rem;
        }
        
        #trailer-player {
            min-height: 160px;
        }
    }

    /* --- Confirmation Popup Styles --- */
    .confirmation-popup-content {
        background: var(--background-secondary);
        width: clamp(300px, 80vw, 450px);
        border-radius: 12px;
        padding: 2rem;
        text-align: center;
        box-shadow: 0 5px 25px rgba(0,0,0,0.4);
        border: 1px solid var(--border-color);
        transform: scale(0.95);
        transition: transform 0.3s ease;
    }
    .episode-popup-overlay.active .confirmation-popup-content {
        transform: scale(1);
    }
    #confirmation-popup-title {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 1rem;
    }
    #confirmation-popup-message {
        font-size: 1rem;
        color: var(--text-secondary);
        line-height: 1.6;
        margin-bottom: 2rem;
    }
    .confirmation-popup-buttons {
        display: flex;
        justify-content: center;
        gap: 1rem;
    }
    .popup-btn {
        padding: 0.75rem 1.5rem;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: 600;
        font-size: 1rem;
        transition: all 0.2s ease;
        min-width: 100px;
    }
    .popup-btn.confirm {
        background-color: var(--brand-accent);
        color: var(--background-primary);
    }
    .popup-btn.confirm:hover {
        background-color: #ffae40; /* Lighter shade of accent */
    }
    .popup-btn.cancel {
        background-color: var(--background-tertiary);
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
    }
    .popup-btn.cancel:hover {
        background-color: #333;
    }

</style>

</head>
<body>
<div class="app-container">
<!-- ****** START: ADD BACK BUTTON ****** -->
<script>
// This script block remains as is, as it's needed for initial setup.
document.addEventListener('DOMContentLoaded', () => {
const urlParams = new URLSearchParams(window.location.search);
const showBackBtn = urlParams.get('anime') === 'true';
const backBtn = document.getElementById('back-button');
if (backBtn) {
backBtn.style.display = showBackBtn ? '' : 'none';
}
});
</script>
<!-- ****** END: ADD BACK BUTTON ****** -->

<header class="series-hero-section">
        <button id="back-button" class="back-btn">
            <i class="fas fa-arrow-left"></i>
        </button>
        <div class="series-hero-content">
            <h1 class="series-title-text"></h1>
        </div>
        <div class="hero-overlay"></div>
    </header>

    <main class="main-content series-main-content">
        <!-- ****** START: UPDATED DETAILS SECTION WITH COLLAPSIBLE WRAPPER ****** -->
        <section class="series-details-section">
            <div class="series-meta-info">
                <span id="series-score"></span>
                <span id="series-year"></span>
                <span id="series-type"></span>
                <span id="series-episodes-count"></span>
                <span id="series-status"></span>
                <span id="series-rating"></span>
            </div>
            
            <div id="details-content-wrapper" class="details-content-wrapper">
                <div class="details-grid">
                    <div> <!-- Left Column -->
                        <p id="series-synopsis"></p>
                    </div>
                    <div> <!-- Right Column -->
                        <div id="series-info-additional">
                            <p><strong>English Title:</strong> <span id="series-title-english"></span></p>
                            <p><strong>Japanese Title:</strong> <span id="series-title-japanese"></span></p>
                            <p><strong>Source:</strong> <span id="series-source"></span></p>
                            <p><strong>Duration:</strong> <span id="series-duration"></span></p>
                        </div>
                        <div class="series-genres"></div>
                        <div class="series-studios"></div>
                        <div class="series-producers"></div>
                    </div>
                </div>
                <section class="trailer-section" id="trailer-section" style="display: none;">
                    <div class="trailer-player-container">
                        <h3 class="trailer-title">
                            <i class="fas fa-play-circle"></i>
                            Trailer
                        </h3>
                        <div id="trailer-player"></div>
                    </div>
                </section>
            </div>
            
            <div id="show-more-container" class="show-more-container" style="display: none;">
                 <button id="show-more-btn" class="show-more-btn">
                    <span>Show More</span> <i class="fas fa-chevron-down"></i>
                 </button>
            </div>
        </section>
        <!-- ****** END: UPDATED DETAILS SECTION ****** -->


        <!-- ****** START: TABS SYSTEM HTML ****** -->
        <section class="tabs-section" id="tabs-section" style="display: none;">
            <div class="tabs-container" id="tabs-container">
                <button class="tab-btn active" data-tab="episodes">Episodes</button>
                <button class="tab-btn" data-tab="related">Related</button>
                <button class="tab-btn" data-tab="recommendations">More Like This</button>
            </div>
            <div class="tab-content-container">
                <!-- Episodes Panel -->
                <div id="tab-panel-episodes" class="tab-panel active">
                    <section class="episode-list-section">
                        <div class="section-header">
                            <h2 class="section-title">Episodes</h2>
                            <button id="thumbnail-toggle-btn" class="thumbnail-toggle-btn" title="Toggle Thumbnails">
                                <i class="fas fa-image"></i>
                            </button>
                        </div>
                        <div class="episodes-loader" id="episodes-loader"></div>
                        <div class="episode-list" id="episode-list-container"></div>
                        <div id="episodes-pagination" class="episodes-pagination"></div>
                    </section>
                </div>
                <!-- Related Panel -->
                <div id="tab-panel-related" class="tab-panel">
                    <div class="related-content-container" id="related-content-container">
                        <!-- Related content will be generated by JS -->
                    </div>
                </div>
                <!-- Recommendations Panel -->
                <div id="tab-panel-recommendations" class="tab-panel">
                    <div class="content-grid" id="recommendations-grid">
                        <!-- Recommendation cards will be generated by JS -->
                    </div>
                </div>
            </div>
        </section>
        <!-- ****** END: TABS SYSTEM HTML ****** -->

    </main>
</div>

<!-- Episode Pop-up Overlay -->
<div id="episode-popup-overlay" class="episode-popup-overlay" style="display:none;">
    <div class="episode-popup-content">
        <button class="episode-popup-back" title="Back">
            <i class="fas fa-arrow-left"></i>
        </button>
        <iframe id="episode-popup-iframe" src="" frameborder="0" allowfullscreen></iframe>
    </div>
</div>

<!-- Confirmation Pop-up -->
<div id="confirmation-popup-overlay" class="episode-popup-overlay" style="display:none;">
    <div id="confirmation-popup-content" class="confirmation-popup-content">
        <h3 id="confirmation-popup-title">Heads Up!</h3>
        <p id="confirmation-popup-message"></p>
        <div class="confirmation-popup-buttons">
            <button id="confirm-btn" class="popup-btn confirm">Watch Again</button>
            <button id="cancel-btn" class="popup-btn cancel">Cancel</button>
        </div>
    </div>
</div>

<script src="src/csplayer.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // ****** START: BACK BUTTON LOGIC ******
        const urlParams = new URLSearchParams(window.location.search);
        const isAnime = urlParams.get('anime') === 'true';
        const isManga = urlParams.get('manga') === 'true';
        const isLibrary = urlParams.get('library') === 'true';
        const type = isManga ? 'manga' : 'anime';
        const API_BASE_URL = 'https://arkm20-authapi.hf.space';
        let userWatchHistory = null;
        let localWatchHistory = {};
        let isSyncing = false; // Flag to prevent multiple syncs
        const backButton = document.getElementById('back-button');
        if (backButton) {
            backButton.style.display = (isAnime || isManga || isLibrary) ? '' : 'none';
            backButton.addEventListener('click', () => {
                if (isLibrary === true) {
                    window.location.href = 'library.html';
                } else {
                    window.location.href = isManga ? 'manga.html' : 'anime.html';
                }
            });
        }
        // ****** END: BACK BUTTON LOGIC ******

        const heroSection = document.querySelector('.series-hero-section');
        const seriesTitleTextElement = document.querySelector('.series-title-text');
        
        const seriesScoreElement = document.getElementById('series-score');
        const seriesYearElement = document.getElementById('series-year');
        const seriesTypeElement = document.getElementById('series-type');
        const seriesEpisodesCountElement = document.getElementById('series-episodes-count');
        const seriesStatusElement = document.getElementById('series-status');
        const seriesRatingElement = document.getElementById('series-rating');
        const seriesSynopsisElement = document.getElementById('series-synopsis');
        const seriesGenresContainer = document.querySelector('.series-genres');
        const seriesStudiosContainer = document.querySelector('.series-studios');
        const seriesProducersContainer = document.querySelector('.series-producers');

        const seriesTitleEnglishElement = document.getElementById('series-title-english');
        const seriesTitleJapaneseElement = document.getElementById('series-title-japanese');
        const seriesSourceElement = document.getElementById('series-source');
        const seriesDurationElement = document.getElementById('series-duration');

        const episodeListContainer = document.getElementById('episode-list-container');
        const episodesPaginationContainer = document.getElementById('episodes-pagination');
        const thumbnailToggleBtn = document.getElementById('thumbnail-toggle-btn');
        const episodesLoader = document.getElementById('episodes-loader');
        
        const tabsSection = document.getElementById('tabs-section');
        const tabsContainer = document.getElementById('tabs-container');
        const tabPanels = document.querySelectorAll('.tab-panel');
        const relatedContainer = document.getElementById('related-content-container');
        const recommendationsContainer = document.getElementById('recommendations-grid');

        // ****** START: COLLAPSIBLE DETAILS SELECTORS ******
        const detailsWrapper = document.getElementById('details-content-wrapper');
        const showMoreContainer = document.getElementById('show-more-container');
        const showMoreBtn = document.getElementById('show-more-btn');
        const showMoreBtnText = showMoreBtn.querySelector('span');
        // ****** END: COLLAPSIBLE DETAILS SELECTORS ******

        let currentMalId = null;
        let currentKitsuId = null;
        let currentSeriesTitle = '';
        let episodesData = [];
        let currentPage = 1;
        const episodesPerPage = 25;

        if( type !== 'anime') {
            if (tabsSection) tabsSection.style.display = 'none'; 
        }

        function getSeriesIdFromUrl() {
            const params = new URLSearchParams(window.location.search);
            return params.get('id');
        }
        
        async function getKitsuId(malId) {
            try {
                const response = await fetch(`https://arkm20-animex-player-api.hf.space/map/mal/${malId}`);
                if (!response.ok) throw new Error('Mapping API failed');
                const data = await response.json();
                return data.kitsu_id;
            } catch (error) {
                console.error(`Failed to map MAL ID ${malId} to Kitsu ID:`, error);
                return null;
            }
        }
        
        async function fetchKitsuData(kitsuId) {
             try {
                if (!kitsuId) return null;
                const response = await fetch(`https://kitsu.io/api/edge/anime/${kitsuId}`);
                if (!response.ok) throw new Error('Kitsu API failed');
                const data = await response.json();
                return data.data;
            } catch (error) {
                console.error(`Failed to fetch Kitsu data for ID ${kitsuId}:`, error);
                return null;
            }
        }

        async function fetchSeriesDetails(seriesId) {
            try {
                const response = await fetch(`https://api.jikan.moe/v4/${type}/${seriesId}/full`);
                if (!response.ok) throw new Error(`Jikan API error (details): ${response.status} ${response.statusText}`);
                const data = await response.json();
                return data.data;
            } catch (error) {
                console.error(`Failed to fetch ${type} details:`, error);
                displayError('Could not load series details. Please try again later.');
            }
        }

        async function fetchSeriesEpisodes(kitsuId) {
            if (type !== 'anime' || !kitsuId) return [];
            let allEpisodes = [];
            let url = `https://kitsu.io/api/edge/anime/${kitsuId}/episodes?page[limit]=20`;

            try {
                while (url) {
                    const response = await fetch(url);
                    if (!response.ok) {
                       console.warn(`Failed to fetch Kitsu episode page: ${response.status}`);
                       break; 
                    }
                    const data = await response.json();
                    if (data.data && data.data.length > 0) {
                        allEpisodes = allEpisodes.concat(data.data);
                    }
                    url = data.links?.next || null;
                    if (url) await new Promise(resolve => setTimeout(resolve, 200));
                }
                allEpisodes.sort((a,b) => a.attributes.number - b.attributes.number);
                return allEpisodes;
            } catch (error) {
                console.error("Failed to fetch Kitsu episodes:", error);
                document.getElementById('tab-panel-episodes').innerHTML = '<p class="info-message">Could not load episodes.</p>';
                if (episodesLoader) episodesLoader.style.display = 'none';
                return [];
            }
        }
        
        async function fetchRelations(seriesId) {
            try {
                const response = await fetch(`https://api.jikan.moe/v4/anime/${seriesId}/relations`);
                if (!response.ok) throw new Error(`Jikan API error (relations): ${response.status}`);
                const data = await response.json();
                return data.data;
            } catch (error) {
                console.error('Failed to fetch relations:', error);
                return [];
            }
        }

        async function fetchRecommendations(seriesId) {
            try {
                const response = await fetch(`https://api.jikan.moe/v4/anime/${seriesId}/recommendations`);
                if (!response.ok) throw new Error(`Jikan API error (recommendations): ${response.status}`);
                const data = await response.json();
                return data.data;
            } catch (error) {
                console.error('Failed to fetch recommendations:', error);
                return [];
            }
        }

        function cleanSynopsis(synopsis) {
            if (!synopsis) return 'No synopsis available.';
            return synopsis.replace(/\[Written by MAL Rewrite\]/gi, '').trim();
        }

        function displayAnimeDetails(anime, kitsuData) {
            if (!anime) return;
            const jikanHeroImage = anime.images?.jpg?.large_image_url || anime.images?.jpg?.image_url;
            const heroImageUrl = jikanHeroImage || 'https://placehold.co/1200x700/141414/FFF?text=No+Image';
            heroSection.style.backgroundImage = `url('${heroImageUrl}')`;
            const displayTitle = anime.title_english || anime.title;
            currentSeriesTitle = displayTitle;
            seriesTitleTextElement.textContent = displayTitle;
            document.title = `${displayTitle} - Series Info`;
            seriesScoreElement.textContent = anime.score ? `Score: ${anime.score}` : 'N/A';
            seriesYearElement.textContent = `${anime.year || (anime.aired?.prop?.from?.year || 'N/A')}`;
            seriesTypeElement.textContent = `${anime.type || 'N/A'}`;
            seriesEpisodesCountElement.textContent = `${anime.episodes || 'N/A'} Episodes`;
            seriesStatusElement.textContent = `${anime.status || 'N/A'}`;
            seriesRatingElement.textContent = `${anime.rating || 'N/A'}`;
            seriesSynopsisElement.innerHTML = cleanSynopsis(anime.synopsis).replace(/\n/g, '<br>');
            seriesTitleEnglishElement.textContent = anime.title_english || 'N/A';
            seriesTitleJapaneseElement.textContent = anime.title_japanese || 'N/A';
            seriesSourceElement.textContent = anime.source || 'N/A';
            seriesDurationElement.textContent = anime.duration || 'N/A';
            seriesGenresContainer.innerHTML = '<strong>Genres:</strong> ';
            [...anime.genres, ...anime.explicit_genres || [], ...anime.themes || [], ...anime.demographics || []].forEach(g => {
                const genreSpan = document.createElement('span');
                genreSpan.textContent = g.name;
                seriesGenresContainer.appendChild(genreSpan);
            });
            seriesStudiosContainer.innerHTML = '<strong>Studios:</strong> ';
            anime.studios.forEach(s => {
                const studioSpan = document.createElement('span');
                studioSpan.textContent = s.name;
                seriesStudiosContainer.appendChild(studioSpan);
            });
            seriesProducersContainer.innerHTML = '<strong>Producers:</strong> ';
            anime.producers.forEach(p => {
                const producerSpan = document.createElement('span');
                producerSpan.textContent = p.name;
                seriesProducersContainer.appendChild(producerSpan);
            });
            if (type === 'anime' && kitsuData) {
                setupTrailerPlayer(kitsuData);
            }
        }

        function displayEpisodes(episodes) {
            if (episodesLoader) episodesLoader.style.display = 'none';
            if (!episodes || episodes.length === 0) {
                document.getElementById('tab-panel-episodes').innerHTML = '<p class="info-message">No episodes found for this series.</p>';
                return;
            }
            episodesData = episodes;
            currentPage = 1;
            renderEpisodePage();
            setupPagination(episodesData.length);
        }

        async function displayRelations(relations) {
            relatedContainer.innerHTML = '';
            if (!relations || relations.length === 0) {
                relatedContainer.innerHTML = '<p class="info-message">No related content found.</p>';
                return;
            }
            
            relatedContainer.innerHTML = '<div class="episodes-loader" style="display: block;"></div>'; // Show loader

            const allEntries = relations.flatMap(rel => rel.entry.map(e => ({ ...e, relation: rel.relation })));
            
            const fetchKitsuPoster = async (entry) => {
                let poster = 'https://placehold.co/80x120/1f1f1f/FFF?text=N/A';
                if (entry.type === 'anime') {
                    const kitsuId = await getKitsuId(entry.mal_id);
                    const kitsuData = await fetchKitsuData(kitsuId);
                    poster = kitsuData?.attributes?.posterImage?.small || 'https://placehold.co/80x120/1f1f1f/FFF?text=Anime';
                } else if (entry.type === 'manga') {
                     poster = `https://api.jikan.moe/v4/manga/${entry.mal_id}/pictures`.includes('.jpg') ? `https://api.jikan.moe/v4/manga/${entry.mal_id}/pictures` : 'https://placehold.co/80x120/1f1f1f/FFF?text=Manga';
                }
                return { ...entry, poster };
            };
            
            const entriesWithPosters = await Promise.all(allEntries.map(fetchKitsuPoster));

            relatedContainer.innerHTML = ''; // Clear loader
            
            entriesWithPosters.forEach(entry => {
                const card = document.createElement('a');
                card.className = 'related-card';
                card.href = `series-info.html?id=${entry.mal_id}`;
                
                const displayTitle = entry.title_english || entry.name;
                card.title = displayTitle;

                const imgContainer = document.createElement('div');
                imgContainer.className = 'related-card-img-container';
                
                const img = document.createElement('img');
                img.className = 'related-card-img';
                img.src = entry.poster;
                img.alt = `Poster for ${displayTitle}`;
                img.loading = 'lazy';
                imgContainer.appendChild(img);

                const infoDiv = document.createElement('div');
                infoDiv.className = 'related-card-info';
                
                const title = document.createElement('h4');
                title.className = 'related-card-title';
                title.textContent = displayTitle;
                
                const tag = document.createElement('span');
                tag.className = 'related-card-tag';
                tag.textContent = entry.relation;

                infoDiv.appendChild(title);
                infoDiv.appendChild(tag);
                
                card.appendChild(imgContainer);
                card.appendChild(infoDiv);
                relatedContainer.appendChild(card);
            });
        }
        
        function displayRecommendations(recommendations) {
            recommendationsContainer.innerHTML = '';
            if (!recommendations || recommendations.length === 0) {
                recommendationsContainer.innerHTML = '<p class="info-message">No recommendations found.</p>';
                return;
            }
            
            recommendations.slice(0, 18).forEach(rec => {
                const entry = rec.entry;
                const card = document.createElement('a');
                card.className = 'recommendation-card';
                card.href = `series-info.html?id=${entry.mal_id}`;
                
                // Prioritize English title if available (though often not in this endpoint)
                const displayTitle = entry.title_english || entry.title;
                card.title = displayTitle;
                
                const imgContainer = document.createElement('div');
                imgContainer.className = 'recommendation-card-img-container';

                const img = document.createElement('img');
                img.className = 'recommendation-card-img';
                img.src = entry.images.jpg.large_image_url || entry.images.jpg.image_url;
                img.alt = `Poster for ${displayTitle}`;
                img.loading = 'lazy';
                
                const title = document.createElement('div');
                title.className = 'recommendation-card-title';
                title.textContent = displayTitle;
                
                imgContainer.appendChild(img);
                card.appendChild(imgContainer);
                card.appendChild(title);
                recommendationsContainer.appendChild(card);
            });
        }

        function loadLocalWatchHistory() {
            try {
                const history = localStorage.getItem('watch_history');
                localWatchHistory = history ? JSON.parse(history) : {};
            } catch (e) {
                console.error("Failed to parse local watch history", e);
                localWatchHistory = {};
            }
        }
        
        async function updateUserWatchHistoryOnApi(showId, showTitle, seasonNumber, episodeNumber) {
            const token = localStorage.getItem('accessToken');
            if (!token) return;

            try {
                const params = new URLSearchParams({
                    show_id: showId,
                    show_title: showTitle,
                    season_number: seasonNumber,
                    episode_number: episodeNumber
                });
                const response = await fetch(`${API_BASE_URL}/users/me/watch-history?${params.toString()}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error(`API update failed: ${response.status}`);
                console.log(`Successfully synced episode ${episodeNumber} for show ${showId} to API.`);
            } catch (error) {
                console.error('Failed to update user watch history on API:', error);
            }
        }

        function updateLocalWatchHistory(seriesId, seasonNumber, episodeNumber, seriesTitle) {
            if (!seriesId || !episodeNumber) return;
            if (!localWatchHistory[seriesId]) localWatchHistory[seriesId] = { seasons: {} };
            if (!localWatchHistory[seriesId].seasons[seasonNumber]) localWatchHistory[seriesId].seasons[seasonNumber] = { episodes: {} };
            localWatchHistory[seriesId].seasons[seasonNumber].episodes[episodeNumber] = { watched_at: new Date().toISOString() };
            try {
                localStorage.setItem('watch_history', JSON.stringify(localWatchHistory));
            } catch (e) { console.error("Failed to save local watch history", e); }
            updateUserWatchHistoryOnApi(seriesId, seriesTitle, seasonNumber, episodeNumber);
        }

        async function syncWatchHistory() {
            if (isSyncing) return;
            const token = localStorage.getItem('accessToken');
            if (!token) { console.log("No user token, skipping sync."); return; }
            isSyncing = true;
            console.log("Starting watch history sync...");
            try {
                const response = await fetch(`${API_BASE_URL}/users/me`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (response.status === 401) { localStorage.removeItem('accessToken'); isSyncing = false; return; }
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                const userData = await response.json();
                const remoteHistory = userData.watch_history_detailed || {};
                userWatchHistory = remoteHistory;
                loadLocalWatchHistory();
                for (const showId in remoteHistory) {
                    for (const seasonNum in remoteHistory[showId].seasons) {
                        for (const epNum in remoteHistory[showId].seasons[seasonNum].episodes) {
                             if (!isEpisodeWatched(showId, seasonNum, epNum)) {
                                 if (!localWatchHistory[showId]) localWatchHistory[showId] = { seasons: {} };
                                 if (!localWatchHistory[showId].seasons[seasonNum]) localWatchHistory[showId].seasons[seasonNum] = { episodes: {} };
                                 localWatchHistory[showId].seasons[seasonNum].episodes[epNum] = remoteHistory[showId].seasons[seasonNum].episodes[epNum];
                             }
                        }
                    }
                }
                localStorage.setItem('watch_history', JSON.stringify(localWatchHistory));
                const syncPromises = [];
                for (const showId in localWatchHistory) {
                    if (showId !== currentMalId) continue;
                    for (const seasonNum in localWatchHistory[showId].seasons) {
                        for (const epNum in localWatchHistory[showId].seasons[seasonNum].episodes) {
                            if (!remoteHistory[showId]?.seasons?.[seasonNum]?.episodes?.[epNum]) {
                                console.log(`Queueing upload for locally watched episode: Show ${showId}, S${seasonNum}, E${epNum}`);
                                syncPromises.push(updateUserWatchHistoryOnApi(showId, currentSeriesTitle, seasonNum, epNum));
                            }
                        }
                    }
                }
                await Promise.all(syncPromises);
                console.log("Watch history sync complete.");
            } catch (error) {
                console.error("An error occurred during watch history sync:", error);
            } finally {
                isSyncing = false;
                if (episodesData.length > 0) renderEpisodePage();
            }
        }

        function isEpisodeWatched(seriesId, seasonNumber, episodeNumber) {
            if (userWatchHistory && userWatchHistory[seriesId]?.seasons?.[seasonNumber]?.episodes?.[episodeNumber]) return true;
            if (localWatchHistory && localWatchHistory[seriesId]?.seasons?.[seasonNumber]?.episodes?.[episodeNumber]) return true;
            return false;
        }

        function renderEpisodePage() {
            episodeListContainer.innerHTML = '';
            const start = (currentPage - 1) * episodesPerPage;
            const end = start + episodesPerPage;
            const paginatedEpisodes = episodesData.slice(start, end);
            paginatedEpisodes.forEach((episode) => {
                const episodeItem = document.createElement('div');
                episodeItem.classList.add('episode-item');
                const episodeNumber = episode.attributes.number;
                const seasonNumber = episode.attributes.seasonNumber || 1;
                if (isEpisodeWatched(currentMalId, seasonNumber, episodeNumber)) episodeItem.classList.add('watched');
                const episodeThumbnailDiv = document.createElement('div');
                episodeThumbnailDiv.className = 'episode-thumbnail';
                const thumbnailImg = document.createElement('img');
                thumbnailImg.className = 'episode-thumbnail-img';
                thumbnailImg.src = episode.attributes.thumbnail?.small || 'https://placehold.co/320x180/1f1f1f/FFF?text=?';
                thumbnailImg.loading = 'lazy';
                episodeThumbnailDiv.appendChild(thumbnailImg);
                const episodeNumberSpan = document.createElement('span');
                episodeNumberSpan.classList.add('episode-number');
                episodeNumberSpan.textContent = episodeNumber;
                const episodeInfoDiv = document.createElement('div');
                episodeInfoDiv.classList.add('episode-info');
                const episodeTitle = document.createElement('h4');
                episodeTitle.classList.add('episode-title');
                episodeTitle.textContent = episode.attributes.canonicalTitle || `Episode ${episodeNumber}`;
                episodeInfoDiv.appendChild(episodeTitle);
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'glassy-download-btn episode-download-icon';
                downloadBtn.title = 'Download Episode';
                downloadBtn.innerHTML = '<i class="fas fa-cloud-download"></i>';
                downloadBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    let quality = localStorage.getItem('quality') || '720p';
                    const isDub = true;
                    window.open(`https://arkm20-animex-player-api.hf.space/download?id=${currentMalId}&episode=${episodeNumber}&dub=${isDub}&quality=${quality}`, '_blank');
                });
                episodeItem.appendChild(episodeThumbnailDiv);
                episodeItem.appendChild(episodeNumberSpan);
                episodeItem.appendChild(episodeInfoDiv);
                episodeItem.appendChild(downloadBtn);
                episodeItem.addEventListener('click', (event) => {
                    if (event.target.closest('.episode-download-icon')) return;
                    episodeItem.classList.add('watched');
                    updateLocalWatchHistory(currentMalId, seasonNumber, episodeNumber, currentSeriesTitle);
                    const refererUrl = encodeURIComponent(window.location.href);
                    const url = `view.html?id=${encodeURIComponent(currentMalId)}&ep=${encodeURIComponent(episodeNumber)}&referer=${refererUrl}`;
                    openEpisodePopup(url);
                });
                episodeListContainer.appendChild(episodeItem);
            });
        }

        async function setupTrailerPlayer(kitsuData) {
            const trailerSection = document.getElementById('trailer-section');
            const trailerPlayer = document.getElementById('trailer-player');
            if (!kitsuData || !kitsuData.attributes.youtubeVideoId) {
                trailerSection.style.display = 'none';
                return;
            }
            const youtubeId = kitsuData.attributes.youtubeVideoId;
            try {
                trailerSection.style.display = 'block';
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    trailerPlayer.innerHTML = `<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; background: var(--background-tertiary);"><iframe src="https://www.youtube.com/embed/${youtubeId}?rel=0&modestbranding=1&playsinline=1&enablejsapi=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen title="Anime Trailer"></iframe></div>`;
                } else {
                    try {
                        csPlayer.init("trailer-player", { defaultId: youtubeId, thumbnail: true, theme: "default", loop: false, autoplay: false });
                    } catch (csPlayerError) {
                        console.warn("csPlayer failed, falling back to iframe:", csPlayerError);
                        trailerPlayer.innerHTML = `<div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; background: var(--background-tertiary);"><iframe src="https://www.youtube.com/embed/${youtubeId}?rel=0&modestbranding=1&enablejsapi=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen title="Anime Trailer"></iframe></div>`;
                    }
                }
                console.log(`Trailer loaded for YouTube ID: ${youtubeId}`);
            } catch (error) {
                console.error("Failed to initialize trailer player:", error);
                trailerPlayer.innerHTML = `<div class="no-trailer-message" style="text-align: center; padding: 2rem;"><p style="margin-bottom: 1rem; color: var(--text-muted);">Trailer available on YouTube</p><a href="https://www.youtube.com/watch?v=${youtubeId}" target="_blank" style="display: inline-block; padding: 0.75rem 1.5rem; background: var(--brand-accent); color: var(--background-primary); text-decoration: none; border-radius: 6px; font-weight: 500;"><i class="fab fa-youtube" style="margin-right: 0.5rem;"></i> Watch on YouTube</a></div>`;
            }
        }

        function setupPagination(totalEpisodes) {
            episodesPaginationContainer.innerHTML = '';
            const pageCount = Math.ceil(totalEpisodes / episodesPerPage);
            if (pageCount <= 1) return;
            const prevButton = document.createElement('button');
            prevButton.innerHTML = ' Prev';
            prevButton.disabled = currentPage === 1;
            prevButton.addEventListener('click', () => {
                if (currentPage > 1) { currentPage--; renderEpisodePage(); updatePaginationButtons(pageCount); window.scrollTo(0, document.getElementById('tabs-section').offsetTop); }
            });
            episodesPaginationContainer.appendChild(prevButton);
            const pageInfo = document.createElement('span');
            pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
            episodesPaginationContainer.appendChild(pageInfo);
            const nextButton = document.createElement('button');
            nextButton.innerHTML = 'Next ';
            nextButton.disabled = currentPage === pageCount;
            nextButton.addEventListener('click', () => {
                if (currentPage < pageCount) { currentPage++; renderEpisodePage(); updatePaginationButtons(pageCount); window.scrollTo(0, document.getElementById('tabs-section').offsetTop); }
            });
            episodesPaginationContainer.appendChild(nextButton);
        }

        function updatePaginationButtons(pageCount) {
            const prevButton = episodesPaginationContainer.querySelector('button:first-child');
            const nextButton = episodesPaginationContainer.querySelector('button:last-child');
            const pageInfo = episodesPaginationContainer.querySelector('span');
            if (prevButton) prevButton.disabled = currentPage === 1;
            if (nextButton) nextButton.disabled = currentPage === pageCount;
            if (pageInfo) pageInfo.textContent = ` Page ${currentPage} of ${pageCount} `;
        }

        function displayError(message) {
            const mainContent = document.querySelector('.series-main-content');
            if (mainContent) mainContent.innerHTML = `<p class="error-message" style="color: #ff6b6b; text-align: center; padding: 30px; font-size: 1.2em;">${message}</p>`;
            if(heroSection) heroSection.style.display = 'none';
            if (backButton && message.includes("No series ID specified")) backButton.style.display = 'none';
        }
        
        function setupThumbnailToggle() {
            const storageKey = 'showEpisodeThumbnails';
            let showThumbnails = localStorage.getItem(storageKey) !== 'false';
            function applyPreference() {
                if (showThumbnails) { episodeListContainer.classList.remove('thumbnails-hidden'); thumbnailToggleBtn.classList.add('active'); } 
                else { episodeListContainer.classList.add('thumbnails-hidden'); thumbnailToggleBtn.classList.remove('active'); }
            }
            thumbnailToggleBtn.addEventListener('click', () => { showThumbnails = !showThumbnails; localStorage.setItem(storageKey, showThumbnails); applyPreference(); });
            applyPreference();
        }
        
        function setupTabs() {
            tabsContainer.addEventListener('click', (e) => {
                const targetTab = e.target.closest('.tab-btn');
                if (!targetTab) return;
                
                tabsContainer.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                tabPanels.forEach(panel => panel.classList.remove('active'));

                targetTab.classList.add('active');
                const tabName = targetTab.dataset.tab;
                const activePanel = document.getElementById(`tab-panel-${tabName}`);
                if (activePanel) {
                    activePanel.classList.add('active');
                }
            });
        }
        
        function setupCollapsibleDetails() {
            // Use a timeout to ensure content has rendered and scrollHeight is accurate
            setTimeout(() => {
                const collapsedHeight = parseInt(window.getComputedStyle(detailsWrapper).maxHeight, 10);
                // Check if content is overflowing, with a buffer
                if (detailsWrapper.scrollHeight > collapsedHeight + 50) { 
                    showMoreContainer.style.display = 'block';
                    
                    showMoreBtn.addEventListener('click', () => {
                        const isExpanded = detailsWrapper.classList.toggle('expanded');
                        showMoreBtnText.textContent = isExpanded ? 'Show Less' : 'Show More';
                    });
                } else {
                    // If no overflow, remove the fade effect and the button container itself.
                    detailsWrapper.style.maxHeight = 'none';
                    detailsWrapper.classList.add('expanded'); // This removes the ::after pseudo-element
                    showMoreContainer.style.display = 'none';
                }
            }, 800); // Delay to allow images/trailer to load and affect scrollHeight
        }

        async function handleEpisodeToWatchOnLoad(episodeToWatch) {
            if (!episodeToWatch || !episodesData.length) return;
            const episodeNumberToFind = parseInt(episodeToWatch, 10);
            if (isNaN(episodeNumberToFind)) return;
            const episodeIndex = episodesData.findIndex(ep => ep.attributes.number === episodeNumberToFind);
            if (episodeIndex > -1) {
                const episode = episodesData[episodeIndex];
                const seasonNumber = episode.attributes.seasonNumber || 1;
                const openPlayer = () => {
                    const targetPage = Math.ceil((episodeIndex + 1) / episodesPerPage);
                    if (currentPage !== targetPage) { currentPage = targetPage; renderEpisodePage(); updatePaginationButtons(Math.ceil(episodesData.length / episodesPerPage)); }
                    updateLocalWatchHistory(currentMalId, seasonNumber, episodeNumberToFind, currentSeriesTitle);
                    const episodeItems = episodeListContainer.querySelectorAll('.episode-item');
                    const itemIndexOnPage = episodeIndex % episodesPerPage;
                    if (episodeItems[itemIndexOnPage]) episodeItems[itemIndexOnPage].classList.add('watched');
                    const refererUrl = encodeURIComponent(window.location.href.split('&watch-ep=')[0]);
                    const url = `view.html?id=${encodeURIComponent(currentMalId)}&ep=${encodeURIComponent(episodeNumberToFind)}&referer=${refererUrl}`;
                    openEpisodePopup(url);
                };
                if (isEpisodeWatched(currentMalId, seasonNumber, episodeNumberToFind)) {
                    showConfirmation("You've already seen this episode. Do you want to watch it again?", openPlayer);
                } else {
                    openPlayer();
                }
            }
        }

        async function init() {
            const params = new URLSearchParams(window.location.search);
            currentMalId = params.get('id');
            const episodeToWatchOnLoad = params.get('watch-ep');
            if (!currentMalId) { displayError("No series ID specified in the URL. Example: series-info.html?id=5114"); return; }
            
            setupThumbnailToggle();
            setupTabs();
            loadLocalWatchHistory();

            const seriesDetails = await fetchSeriesDetails(currentMalId);
            
            if (seriesDetails) {
                await syncWatchHistory();
                
                if (type === 'anime') {
                    if (tabsSection) tabsSection.style.display = 'block';

                    currentKitsuId = await getKitsuId(currentMalId);
                    const kitsuData = await fetchKitsuData(currentKitsuId);
                    
                    displayAnimeDetails(seriesDetails, kitsuData);
                    setupCollapsibleDetails();
                    
                    if(episodesLoader) episodesLoader.style.display = 'block';
                    
                    const [episodes, relations, recommendations] = await Promise.all([
                        fetchSeriesEpisodes(currentKitsuId),
                        fetchRelations(currentMalId),
                        fetchRecommendations(currentMalId)
                    ]);
                    
                    displayEpisodes(episodes);
                    displayRelations(relations);
                    displayRecommendations(recommendations);

                    if(episodeToWatchOnLoad) await handleEpisodeToWatchOnLoad(episodeToWatchOnLoad);

                } else { // Manga logic
                    if (tabsSection) tabsSection.style.display = 'none';
                    displayAnimeDetails(seriesDetails, null);
                    setupCollapsibleDetails();
                }
            }
        }

        // --- POPUP OVERLAY LOGIC ---
        const popupOverlay = document.getElementById('episode-popup-overlay');
        const popupIframe = document.getElementById('episode-popup-iframe');
        function openEpisodePopup(url) {
            popupIframe.src = url;
            popupOverlay.style.display = 'flex';
            setTimeout(() => popupOverlay.classList.add('active'), 10);
            document.body.style.overflow = 'hidden';
        }
        function closeEpisodePopup() {
            popupOverlay.classList.remove('active');
            setTimeout(() => { popupOverlay.style.display = 'none'; popupIframe.src = ''; document.body.style.overflow = ''; }, 300);
        }
        const popupBackBtn = popupOverlay.querySelector('.episode-popup-back');
        popupBackBtn.addEventListener('click', closeEpisodePopup);
        popupOverlay.addEventListener('click', (e) => { if (e.target === popupOverlay) closeEpisodePopup(); });

        // --- CONFIRMATION POPUP LOGIC ---
        const confirmOverlay = document.getElementById('confirmation-popup-overlay');
        const confirmMessage = document.getElementById('confirmation-popup-message');
        const confirmBtn = document.getElementById('confirm-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        let confirmCallback = null;
        function showConfirmation(message, onConfirm) {
            confirmMessage.textContent = message;
            confirmCallback = onConfirm;
            confirmOverlay.style.display = 'flex';
            setTimeout(() => confirmOverlay.classList.add('active'), 10);
            document.body.style.overflow = 'hidden';
        }
        function closeConfirmation() {
            confirmOverlay.classList.remove('active');
            setTimeout(() => { confirmOverlay.style.display = 'none'; document.body.style.overflow = ''; }, 300);
        }
        confirmBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); closeConfirmation(); });
        cancelBtn.addEventListener('click', closeConfirmation);
        confirmOverlay.addEventListener('click', (e) => { if (e.target === confirmOverlay) closeConfirmation(); });

        init();
    });
</script>
</body>
</html>